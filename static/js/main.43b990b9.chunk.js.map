{"version":3,"sources":["PathFinderVisualizer/Node/Node.jsx","Algorithms/dijkstras.js","Algorithms/MazeGeneration.js","Algorithms/AStarSearch.js","PathFinderVisualizer/PathFinderVisualization.jsx","Algorithms/BreadthFirstSearch.js","Algorithms/DepthFirstSearch.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","mouseClicked","nodeRow","nodeCol","nodeClass","this","isStart","isEnd","handleNodeClick","onMouseDown","handleNodeEntered","onMouseEnter","className","setNodeClass","id","setNodeId","React","Component","minDistance","grid","numRows","numCols","minCoords","min","Infinity","currRow","currCol","isVisited","distance","getPath","currNode","pathArray","parent","push","NodePos","row","col","getOrientation","randomInt","max","Math","floor","random","getManhattanDist","endRow","endCol","abs","nodeIsInList","openList","node","i","length","SCREEN_WIDTH","window","innerWidth","SCREEN_HEIGHT","innerHeight","NUM_ROWS","NUM_COLS","algos","DIJKSTRAS","ASTAR","BFS","DFS","walls","PathFinderVisualizer","currAlgo","wallWeight","startNodeClicked","startRow","startCol","endNodeClicked","prevRow","prevCol","createGrid","nextProps","nextState","isFinish","isWall","weight","g","f","j","createNode","setState","document","getElementById","currNodeClassWeight","getNodeClassWeight","isStartNode","isEndNode","currWallWeight","getWallWeightAsInt","updateNodeProps","Object","assign","updateStartProps","updateEndProps","includes","newRow","newCol","oldStartRow","oldStartCol","oldEndRow","oldEndCol","clickedNode","updateGridWall","wallClassName","getWallClassName","enteredNode","wallClicked","updateStartNode","updateEndNode","animationTimerTop","animationTimerBot","animationTimerRight","animationTimerLeft","currWallTop","setTimeout","currWallBot","currWallRight","currWallLeft","clearGrid","setButtonState","wallPositions","animationTimer","orientation","genOuterWalls","generateMaze","stratCol","randWallCol","randWallRow","wallCol","wallRow","colRandomizer","rowRandomizer","colPassage","rowPassage","colDir","rowDir","wall","newNumCols","newNumRows","currWall","randomWeight","randWeight","getRandomWeight","stringWeight","nodeWeight","nodeClassName","clearVistedAndPath","visitedNodes","coords","minNodeRow","minNodeCol","minNode","minNodeDistance","visitedNodeSet","nodeUp","distanceUp","weightUp","nodeDown","distanceDown","weightDown","nodeRight","distanceRight","weightRight","nodeLeft","distanceLeft","weightLeft","dijkstras","visitedNode","visitedNodeDOM","visitedNodeClassName","visitedClassName","substr","path","pathNode","pathNodeDOM","pathNodeClassName","newPathNodeClassName","closedList","startNode","qIdx","splice","isInClosedList","isInOpenList","gNew","fNew","hNew","h","aStarSearch","nodeQueue","shift","visitedUp","visitedDown","visitedRight","visitedLeft","breadthFirstSearch","nodeStack","pop","depthFirstSearch","algo","dijkstrasVisualize","aStarVisualize","bfsVisualize","dfsVisualize","visualizeButton","innerHTML","wallWeightBadge","newWallWeight","disabled","Navbar","bg","variant","expand","Brand","DropdownButton","title","Dropdown","Item","as","onClick","setAlgo","genMaze","Button","visualize","Text","Badge","ButtonGroup","size","increaseWeight","decreaseWeight","onMouseUp","handleMouseUp","map","rowIndex","key","colIndex","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.43b990b9.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\n\r\nexport default class Node extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            mouseClicked: false,\r\n        }\r\n    }\r\n\r\n    setNodeId(nodeRow, nodeCol) {\r\n        let nodeID = `row-${nodeRow}-col-${nodeCol}`;\r\n        return nodeID;\r\n    }\r\n\r\n    setNodeClass(nodeRow, nodeCol) {\r\n        let nodeClass = \"node\";\r\n        if (this.props.isStart) {\r\n            nodeClass = \"start-node\";\r\n        } else if (this.props.isEnd) {\r\n            nodeClass = \"end-node\";\r\n        }\r\n        return nodeClass;\r\n    }\r\n\r\n    render() {\r\n        const handleNodeClick = this.props.onMouseDown;\r\n        const handleNodeEntered = this.props.onMouseEnter;\r\n\r\n        return (\r\n        <div \r\n            className= {this.setNodeClass(this.props.nodeRow, this.props.nodeCol)}\r\n            id = {this.setNodeId(this.props.nodeRow, this.props.nodeCol)}\r\n            onMouseDown = {() => handleNodeClick()}\r\n            onMouseEnter = {() => handleNodeEntered()}\r\n        ></div>);\r\n    }\r\n}\r\n","function minDistance(grid, numRows, numCols) {\r\n    let min = Infinity;\r\n    let minCoords;\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0; currCol < numCols; currCol++) {\r\n            if (grid[currRow][currCol].isVisited === false && grid[currRow][currCol].distance <= min) {\r\n                min = grid[currRow][currCol].distance;\r\n                minCoords = {\r\n                    nodeRow: currRow,\r\n                    nodeCol: currCol,\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return minCoords;\r\n}\r\n\r\nexport function getPath(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPath(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function dijkstras(grid, numRows, numCols, endRow, endCol) {\r\n    const visitedNodes = [];\r\n\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0 ; currCol < numCols; currCol++) {\r\n            // Get the node with the min distance and set it to visited\r\n            const coords = minDistance(grid, numRows, numCols);\r\n            const minNodeRow = coords.nodeRow;\r\n            const minNodeCol = coords.nodeCol;\r\n            const minNode = grid[minNodeRow][minNodeCol];\r\n            Object.assign(minNode, {isVisited: true});\r\n            if (minNodeRow === endRow && minNodeCol === endCol) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            // Update adjacent nodes\r\n            const minNodeDistance = minNode.distance;\r\n            const visitedNodeSet = [];\r\n            \r\n            // Update node above\r\n            if (minNodeRow + 1 < numRows) {\r\n                const nodeUp = grid[minNodeRow + 1][minNodeCol];\r\n                const distanceUp = nodeUp.distance;\r\n                const weightUp = nodeUp.weight;\r\n                const visitedUp = nodeUp.isVisited;\r\n                if (visitedUp === false && minNodeDistance + weightUp < distanceUp) {\r\n                    Object.assign(nodeUp, {parent: minNode});\r\n                    Object.assign(nodeUp, {distance: minNodeDistance + weightUp});\r\n                    visitedNodeSet.push(nodeUp);\r\n                }\r\n            }\r\n\r\n            // Update node below\r\n            if (minNodeRow - 1 >= 0) {\r\n                const nodeDown = grid[minNodeRow - 1][minNodeCol];\r\n                const distanceDown = nodeDown.distance;\r\n                const weightDown = nodeDown.weight;\r\n                const visitedDown = nodeDown.isVisited;\r\n                if (visitedDown === false && minNodeDistance + weightDown < distanceDown) {\r\n                    Object.assign(nodeDown, {parent: minNode});\r\n                    Object.assign(nodeDown, {distance: minNodeDistance + weightDown});\r\n                    visitedNodeSet.push(nodeDown);\r\n                }\r\n            }\r\n\r\n            // Update node right\r\n            if (minNodeCol + 1 < numCols) {\r\n                const nodeRight = grid[minNodeRow][minNodeCol + 1];\r\n                const distanceRight = nodeRight.distance;\r\n                const weightRight = nodeRight.weight;\r\n                const visitedRight = nodeRight.isVisited;\r\n                if (visitedRight === false && minNodeDistance + weightRight < distanceRight) {\r\n                    Object.assign(nodeRight, {parent: minNode});\r\n                    Object.assign(nodeRight, {distance: minNodeDistance + weightRight});\r\n                    visitedNodeSet.push(nodeRight);\r\n                }\r\n            }\r\n\r\n            // Update node left\r\n            if (minNodeCol - 1 >= 0) {\r\n                const nodeLeft = grid[minNodeRow][minNodeCol - 1];\r\n                const distanceLeft = nodeLeft.distance;\r\n                const weightLeft = nodeLeft.weight;\r\n                const visitedLeft = nodeLeft.isVisited;\r\n                if (visitedLeft === false && minNodeDistance + weightLeft < distanceLeft) {\r\n                    Object.assign(nodeLeft, {parent: minNode});\r\n                    Object.assign(nodeLeft, {distance: minNodeDistance + weightLeft});\r\n                    visitedNodeSet.push(nodeLeft);\r\n                }\r\n            }\r\n\r\n            if (visitedNodeSet.length > 0) {\r\n                visitedNodes.push(visitedNodeSet);\r\n            }\r\n        }\r\n    }\r\n}\r\n","function NodePos(row, col) {\r\n    this.row = row;\r\n    this.col = col;\r\n}\r\n\r\nexport function generateMaze(row, col, numRows, numCols, orientation, wallPositions, startRow, stratCol, endRow, endCol) {\r\n    if ((numRows <= 2) || (numCols <= 1)) {\r\n        return;\r\n    }\r\n    \r\n    // Get the wall position\r\n    let randWallCol = randomInt(1, numCols - 2);\r\n    let randWallRow = randomInt(1, numRows - 2);\r\n    let wallCol = col + (orientation === \"horizontal\" ? 0 : randWallCol);\r\n    let wallRow = row + (orientation === \"vertical\" ? 0 : randWallRow);\r\n\r\n    // Get the passage position\r\n    let colRandomizer = randomInt(0, 1);\r\n    if (colRandomizer === 1) colRandomizer = numCols - 1;\r\n    let rowRandomizer = randomInt(0, 1);\r\n    if (rowRandomizer === 1) rowRandomizer = numRows - 1;\r\n    const colPassage = wallCol + (orientation === \"horizontal\" ? colRandomizer : 0);\r\n    const rowPassage = wallRow + (orientation === \"vertical\" ? rowRandomizer : 0);\r\n\r\n    // Get the direction the wall should extend\r\n    const colDir = orientation === \"horizontal\" ? 1 : 0;\r\n    const rowDir = orientation === \"vertical\" ? 1 : 0;\r\n\r\n    const length = orientation === \"horizontal\" ? numCols : numRows;\r\n    for (let i = 0; i < length; i++) {\r\n        const notPassage = (wallCol !== colPassage || wallRow !== rowPassage);\r\n        const notStart = (wallCol !== stratCol || wallRow !== startRow);\r\n        const notEnd = (wallCol !== endCol || wallRow !== endRow);\r\n        const createWall = notPassage && notStart && notEnd;\r\n        if (createWall) {\r\n            const wall = new NodePos(wallRow, wallCol);\r\n            wallPositions.push(wall);\r\n        }\r\n        wallCol += colDir;\r\n        wallRow += rowDir;\r\n    }\r\n\r\n    let newCol = col;\r\n    let newRow = row;\r\n    let newNumCols = orientation === \"horizontal\" ? numCols : wallCol - col;\r\n    let newNumRows = orientation === \"vertical\" ? numRows : wallRow - row;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n\r\n    newCol = orientation === \"horizontal\" ? col : wallCol + 1;\r\n    newRow = orientation === \"vertical\" ? row : wallRow + 1;\r\n    newNumCols = orientation === \"horizontal\" ? numCols : col + numCols - wallCol - 1;\r\n    newNumRows = orientation === \"vertical\" ? numRows : row + numRows - wallRow - 1;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n}\r\n\r\nfunction getOrientation(numRows, numCols) {\r\n    if (numRows < numCols) {\r\n        return \"vertical\";\r\n    } else {\r\n        return \"horizontal\"\r\n    }\r\n}\r\n\r\nfunction randomInt(min, max) {\r\n    const randNum = Math.floor(Math.random() * (max - min + 1) + min);\r\n    return randNum;\r\n}\r\n","export function aStarSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const openList = [];\r\n    const closedList = [];\r\n    const visitedNodes = [];\r\n\r\n    const startNode = grid[startRow][startCol];\r\n    openList.push(startNode);\r\n\r\n    while(openList.length > 0) {\r\n        // Find node with lowest f val in open list\r\n        let currNode = openList[0];\r\n        let qIdx = 0;\r\n        for (let i = 1; i < openList.length; i++) {\r\n            if (openList[i].f < currNode.f) {\r\n                currNode = openList[i];\r\n                qIdx = i;\r\n            }\r\n        }\r\n\r\n        // Current node is the end node, return\r\n        if (currNode.row === endRow && currNode.col === endCol) {\r\n            return visitedNodes;\r\n        }\r\n\r\n        if (currNode !== startNode) visitedNodes.push(currNode);\r\n\r\n        // Pop Q off open list\r\n        openList.splice(qIdx, 1);\r\n        closedList.push(currNode);\r\n\r\n        // Update node above\r\n        if (currNode.row + 1 < numRows) {\r\n            const nodeUp = grid[currNode.row + 1][currNode.col];\r\n            let isInClosedList = nodeIsInList(closedList, nodeUp);\r\n            let isInOpenList = nodeIsInList(openList, nodeUp);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeUp.weight;\r\n                const hNew = getManhattanDist(nodeUp.row, nodeUp.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeUp.g) {\r\n                    Object.assign(nodeUp, {parent: currNode});\r\n                    Object.assign(nodeUp, {g: gNew});\r\n                    Object.assign(nodeUp, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeUp);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (currNode.row - 1 >= 0) {\r\n            const nodeDown = grid[currNode.row - 1][currNode.col];\r\n            let isInClosedList = nodeIsInList(closedList, nodeDown);\r\n            let isInOpenList = nodeIsInList(openList, nodeDown);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeDown.weight;\r\n                const hNew = getManhattanDist(nodeDown.row, nodeDown.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeDown.g) {\r\n                    Object.assign(nodeDown, {parent: currNode});\r\n                    Object.assign(nodeDown, {g: gNew});\r\n                    Object.assign(nodeDown, {h: hNew});\r\n                    Object.assign(nodeDown, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeDown);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (currNode.col + 1 < numCols) {\r\n            const nodeRight = grid[currNode.row][currNode.col + 1];\r\n            let isInClosedList = nodeIsInList(closedList, nodeRight);\r\n            let isInOpenList = nodeIsInList(openList, nodeRight);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeRight.weight;\r\n                const hNew = getManhattanDist(nodeRight.row, nodeRight.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeRight.g) {\r\n                    Object.assign(nodeRight, {parent: currNode});\r\n                    Object.assign(nodeRight, {g: gNew});\r\n                    Object.assign(nodeRight, {h: hNew});\r\n                    Object.assign(nodeRight, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeRight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (currNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[currNode.row][currNode.col - 1];\r\n            let isInClosedList = nodeIsInList(closedList, nodeLeft);\r\n            let isInOpenList = nodeIsInList(openList, nodeLeft);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeLeft.weight;\r\n                const hNew = getManhattanDist(nodeLeft.row, nodeLeft.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeLeft.g) {\r\n                    Object.assign(nodeLeft, {parent: currNode});\r\n                    Object.assign(nodeLeft, {g: gNew});\r\n                    Object.assign(nodeLeft, {h: hNew});\r\n                    Object.assign(nodeLeft, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeLeft);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\nfunction getManhattanDist(currRow, currCol, endRow, endCol) {\r\n    return Math.abs(currRow - endRow) + Math.abs(currCol - endCol);\r\n}\r\n\r\nfunction nodeIsInList(openList, node) {\r\n    for (let i = 0; i < openList.length; i++) {\r\n        if (openList[i].row === node.row && openList[i].col === node.col) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport './PathFinderVisualization.css'\r\nimport './Node/Node.css'\r\nimport {dijkstras, getPath} from '../Algorithms/dijkstras';\r\nimport {generateMaze} from '../Algorithms/MazeGeneration';\r\nimport {breadthFirstSearch} from '../Algorithms/BreadthFirstSearch';\r\nimport {depthFirstSearch} from '../Algorithms/DepthFirstSearch';\r\nimport {aStarSearch} from '../Algorithms/AStarSearch'\r\nimport { Button, Dropdown, Navbar, ButtonGroup, DropdownButton, Badge } from 'react-bootstrap';\r\n\r\nconst SCREEN_WIDTH = window.innerWidth;\r\nconst SCREEN_HEIGHT = window.innerHeight;\r\nconst NODE_SIZE = 30;\r\nconst NUM_ROWS = Math.floor((SCREEN_HEIGHT / NODE_SIZE) - 4);\r\nconst NUM_COLS = Math.floor((SCREEN_WIDTH / NODE_SIZE) - 4);\r\nconst ANIMATION_SPEED = 5;\r\nconst algos = {\r\n    DIJKSTRAS: \"dijkstras\",\r\n    ASTAR: \"aStar\",\r\n    BFS: \"bfs\",\r\n    DFS: \"dfs\",\r\n}\r\nconst walls = {\r\n    INFINITY: \"wall-node-infinity\",\r\n    FIVE: \"wall-node-five\",\r\n    FOUR: \"wall-node-four\",\r\n    THREE: \"wall-node-three\",\r\n    TWO: \"wall-node-two\",\r\n    ONE: \"wall-node-one\",\r\n}\r\n\r\nexport default class PathFinderVisualizer extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            currAlgo: algos.DIJKSTRAS,\r\n            wallWeight: Infinity,\r\n            grid: [],\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            startRow: 1,\r\n            startCol: 1,\r\n            endNodeClicked: false,\r\n            endRow: NUM_ROWS - 2,\r\n            endCol: NUM_COLS - 2,\r\n            prevRow: -1,\r\n            prevCol: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.createGrid();\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        if (this.state.mouseClicked) return false;\r\n        return true;\r\n    }\r\n\r\n    createNode(nodeRow, nodeCol) {\r\n        const isStart = nodeCol === this.state.startCol && nodeRow === this.state.startRow;\r\n        const isFinish = nodeCol === this.state.endCol && nodeRow === this.state.endRow;\r\n        let node = {\r\n            row: nodeRow,\r\n            col: nodeCol,\r\n            isStart: isStart,\r\n            isFinish: isFinish,\r\n            isWall: false,\r\n            isVisited: false,\r\n            weight: 1,\r\n            distance: (isStart) ? 0 : Infinity,\r\n            parent: (isStart) ? \"NO_PARENT\" : null,\r\n            g: (isStart) ? 0 : Infinity,\r\n            f: (isStart) ? 0 : Infinity,\r\n        }\r\n        return node;\r\n    }\r\n\r\n    createGrid() {\r\n        const grid = [];\r\n        for (let i = 0; i < NUM_ROWS; i++) {\r\n            const row = [];\r\n            for (let j = 0; j < NUM_COLS; j++) {\r\n                const node = this.createNode(i, j);\r\n                row.push(node);\r\n            }\r\n            grid.push(row);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    clearGrid() {\r\n        this.createGrid();\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                if (!(currNode.className === \"start-node\") && !(currNode.className === \"end-node\")) {\r\n                    currNode.className = \"node\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearVistedAndPath() {\r\n        const grid = this.state.grid;\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                const nodeIsWall = currNode.className === \"wall-node-infinity\";\r\n                if (nodeIsWall) continue;\r\n                const currNodeClassWeight = this.getNodeClassWeight(currNode.className);\r\n                const isStartNode = currNode.className === \"start-node\";\r\n                const isEndNode = currNode.className === \"end-node\";\r\n                if (currNodeClassWeight !== \"\") {\r\n                    currNode.className = \"wall-node\" + currNodeClassWeight;\r\n                    const currWallWeight = this.getWallWeightAsInt(currNodeClassWeight);\r\n                    this.updateNodeProps(currRow, currCol);\r\n                    Object.assign(grid[currRow][currCol], {isWall: true});\r\n                    Object.assign(grid[currRow][currCol], {weight: currWallWeight});\r\n                } else if (isStartNode) {\r\n                    this.updateStartProps(currRow, currCol);\r\n                } else if (isEndNode) {\r\n                    this.updateEndProps(currRow, currCol) ;\r\n                } else {\r\n                    currNode.className = \"node\";\r\n                    this.updateNodeProps(currRow, currCol) ;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateGridWall(nodeRow, nodeCol, weight) {\r\n        const grid = this.state.grid;\r\n        const currNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const nodeIsWall = currNode.className.includes(\"wall-node\");\r\n        if (nodeIsWall) {\r\n            this.updateNodeProps(nodeRow, nodeCol);\r\n            Object.assign(grid[nodeRow][nodeCol], {isWall: true});\r\n            Object.assign(grid[nodeRow][nodeCol], {weight: weight});\r\n        } if (currNode.className === \"node\") {\r\n            this.updateNodeProps(nodeRow, nodeCol);\r\n        }\r\n    }\r\n\r\n    updateNodeProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: \"NO_PARENT\"});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: 0});\r\n    }\r\n\r\n    updateEndProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartNode(newRow, newCol) {\r\n        const oldStartRow = this.state.startRow;\r\n        const oldStartCol = this.state.startCol;\r\n\r\n        // Update the old start node to be a regular node\r\n        this.updateNodeProps(oldStartRow, oldStartCol);\r\n\r\n        // Update the entered node to be the new start node\r\n        this.updateStartProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            startRow: newRow,\r\n            startCol: newCol,\r\n        });\r\n    }\r\n\r\n    updateEndNode(newRow, newCol) {\r\n        const oldEndRow = this.state.endRow;\r\n        const oldEndCol = this.state.endCol;\r\n\r\n        // Update the old end node to be a regular node\r\n        this.updateNodeProps(oldEndRow, oldEndCol);\r\n\r\n        // Update the entered node to be the new end node\r\n        this.updateEndProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            endRow: newRow,\r\n            endCol: newCol,\r\n        });\r\n    }\r\n\r\n    isStart(nodeRow, nodeCol) {\r\n        const isStart = nodeRow === this.state.startRow && nodeCol === this.state.startCol;\r\n        return isStart ? true : false;\r\n    }\r\n    \r\n    isEnd(nodeRow, nodeCol) {\r\n        const isEnd = nodeRow === this.state.endRow && nodeCol === this.state.endCol;\r\n        return isEnd ? true : false;\r\n    }\r\n\r\n    getWallClassName(weight) {\r\n        let wallClassName;\r\n        if (weight === 1) {\r\n            wallClassName = walls.ONE;\r\n        } else if (weight === 2) {\r\n            wallClassName = walls.TWO;\r\n        } else if (weight === 3) {\r\n            wallClassName = walls.THREE;\r\n        } else if (weight === 4) {\r\n            wallClassName = walls.FOUR;\r\n        } else if (weight === 5) {\r\n            wallClassName = walls.FIVE;\r\n        } else {\r\n            wallClassName = walls.INFINITY;\r\n        }\r\n        return wallClassName;\r\n    }\r\n\r\n    handleNodeClick(nodeRow, nodeCol) {\r\n        const clickedNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const wallClicked = clickedNode.className.includes(\"wall-node\");\r\n\r\n        if (wallClicked) {\r\n            clickedNode.className = \"node\";\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"node\") {\r\n            const wallClassName = this.getWallClassName(this.state.wallWeight);\r\n            clickedNode.className = wallClassName;\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"end-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                endNodeClicked: true,\r\n            });\r\n        } else if (clickedNode.className === \"start-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                startNodeClicked: true,\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNodeEntered(nodeRow, nodeCol) {\r\n        if (nodeRow === this.state.prevRow && nodeCol === this.state.prevCol) return;\r\n        const enteredNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const wallClicked = enteredNode.className.includes(\"wall-node\");\r\n        \r\n        if (this.state.startNodeClicked) {\r\n            if (nodeRow === this.state.endRow && nodeCol === this.state.endCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"start-node\";\r\n            this.updateStartNode(nodeRow, nodeCol);\r\n        } else if (this.state.endNodeClicked) {\r\n            if (nodeRow === this.state.startRow && nodeCol === this.state.startCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"end-node\";\r\n            this.updateEndNode(nodeRow, nodeCol);\r\n        } else if (this.state.mouseClicked) {\r\n            if (wallClicked) {\r\n                enteredNode.className = \"node\";\r\n            } else if (enteredNode.className === \"node\") {\r\n                const wallClassName = this.getWallClassName(this.state.wallWeight);\r\n                enteredNode.className = wallClassName;\r\n                enteredNode.className = wallClassName;\r\n            }\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n        }\r\n\r\n        this.setState({\r\n            prevRow: nodeRow,\r\n            prevCol: nodeCol,\r\n        });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            endNodeClicked: false,\r\n        });\r\n    }\r\n\r\n    genOuterWalls() {\r\n        let animationTimerTop = 0;\r\n        let animationTimerBot = 0;\r\n        let animationTimerRight = 0\r\n        let animationTimerLeft = 0\r\n\r\n        for (let i = 0 ; i < NUM_COLS; i++) {\r\n            const currWallTop = document.getElementById(`row-${0}-col-${i}`);\r\n            if (currWallTop.className === \"start-node\" || currWallTop.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallTop.className = \"wall-node-infinity\";\r\n                this.updateGridWall(0, i, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerTop);\r\n            animationTimerTop += 2;\r\n        }\r\n\r\n        for (let i = NUM_COLS - 1 ; i >= 0; i--) {\r\n            const currWallBot = document.getElementById(`row-${NUM_ROWS - 1}-col-${i}`);\r\n            if (currWallBot.className === \"start-node\" || currWallBot.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallBot.className = \"wall-node-infinity\";\r\n                this.updateGridWall(NUM_ROWS - 1, i, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerBot);\r\n            animationTimerBot += 2;\r\n        }\r\n\r\n        animationTimerRight = animationTimerLeft = animationTimerTop;\r\n        for (let i = 1; i < NUM_ROWS - 1; i++) {\r\n            const currWallRight = document.getElementById(`row-${i}-col-${NUM_COLS - 1}`);\r\n            if (currWallRight.className === \"start-node\" || currWallRight.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallRight.className = \"wall-node-infinity\";\r\n                this.updateGridWall(i, NUM_COLS - 1, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerRight);\r\n            animationTimerRight += 2;\r\n        }\r\n\r\n        for (let i = NUM_ROWS - 2; i >= 0; i--) {\r\n            const currWallLeft = document.getElementById(`row-${i}-col-${0}`);\r\n            if (currWallLeft.className === \"start-node\" || currWallLeft.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallLeft.className = \"wall-node-infinity\";\r\n                this.updateGridWall(i, 0, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerLeft);\r\n            animationTimerLeft += 2;\r\n        }\r\n\r\n        return animationTimerLeft;\r\n    }\r\n\r\n    genMaze(weight) {\r\n        this.clearGrid();\r\n        this.setButtonState(true);\r\n        const wallPositions = [];\r\n        let animationTimer = 0;\r\n        const orientation = NUM_ROWS < NUM_COLS ? \"vertical\" : \"horizontal\";\r\n        animationTimer = this.genOuterWalls();\r\n        generateMaze(1, 1, NUM_ROWS - 2, NUM_COLS - 2, orientation, wallPositions, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        for (let i = 0; i < wallPositions.length; i++) {\r\n            const wallRow = wallPositions[i].row;\r\n            const wallCol = wallPositions[i].col;\r\n            const currWall = document.getElementById(`row-${wallRow}-col-${wallCol}`);\r\n            setTimeout(() => {\r\n                const randomWeight = getRandomWeight();\r\n                const wallWeight = weight === -1 ? randomWeight : weight;\r\n                const wallClassName = this.getWallClassName(wallWeight);\r\n                currWall.className = wallClassName;\r\n                this.updateGridWall(wallRow, wallCol, wallWeight);\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            this.setState({mouseClicked: false});\r\n            animationTimer += 2;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    getWallWeightAsInt(stringWeight) {\r\n        let nodeWeight = 1;\r\n        if (stringWeight.includes(\"five\")) {\r\n            nodeWeight = 5;\r\n        } else if (stringWeight.includes(\"four\")) {\r\n            nodeWeight = 4;\r\n        } else if (stringWeight.includes(\"three\")) {\r\n            nodeWeight = 3;\r\n        } else if (stringWeight.includes(\"two\")) {\r\n            nodeWeight = 2;\r\n        } else if (stringWeight.includes(\"one\")) {\r\n            nodeWeight = 1;\r\n        }\r\n        return nodeWeight;\r\n    }\r\n\r\n    getNodeClassWeight(nodeClassName) {\r\n        let nodeWeight = \"\";\r\n        if (nodeClassName.includes(\"five\")) {\r\n            nodeWeight = \"-five\";\r\n        } else if (nodeClassName.includes(\"four\")) {\r\n            nodeWeight = \"-four\";\r\n        } else if (nodeClassName.includes(\"three\")) {\r\n            nodeWeight = \"-three\";\r\n        } else if (nodeClassName.includes(\"two\")) {\r\n            nodeWeight = \"-two\";\r\n        } else if (nodeClassName.includes(\"one\")) {\r\n            nodeWeight = \"-one\";\r\n        }\r\n        return nodeWeight;\r\n    }\r\n\r\n    dijkstrasVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = dijkstras(grid, NUM_ROWS, NUM_COLS, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                const visitedNodeClassName = visitedNodeDOM.className;\r\n                if (visitedNodeClassName.includes(\"wall-node\")) {\r\n                    const wallWeight = visitedNodeClassName.substr(9);\r\n                    const visitedClassName = \"visited-node\" + wallWeight;\r\n                    setTimeout(() => {\r\n                        visitedNodeDOM.className = visitedClassName;\r\n                    }, ANIMATION_SPEED * animationTimer);\r\n                } else {\r\n                    setTimeout(() => {\r\n                        visitedNodeDOM.className = \"visited-node\";\r\n                    }, ANIMATION_SPEED * animationTimer);\r\n                }\r\n            }\r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const pathNodeClassName = pathNodeDOM.className;\r\n            const pathWeight = this.getNodeClassWeight(pathNodeClassName);\r\n            const newPathNodeClassName = \"path-node\" + pathWeight;\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = newPathNodeClassName;\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n        \r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    aStarVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = aStarSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const visitedNode = visitedNodes[i];\r\n            if (visitedNode.isFinish) break;\r\n            const nodeRow = visitedNode.row;\r\n            const nodeCol = visitedNode.col;\r\n            const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const visitedNodeClassName = visitedNodeDOM.className;\r\n            if (visitedNodeClassName.includes(\"wall-node\")) {\r\n                const wallWeight = visitedNodeClassName.substr(9);\r\n                const visitedClassName = \"visited-node\" + wallWeight;\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = visitedClassName;\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            } else {\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 2;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const pathNodeClassName = pathNodeDOM.className;\r\n            const pathWeight = this.getNodeClassWeight(pathNodeClassName);\r\n            const newPathNodeClassName = \"path-node\" + pathWeight;\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = newPathNodeClassName;\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    bfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = breadthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    dfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = depthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n                const visitedNode = visitedNodes[i];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            \r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    visualize(algo) {\r\n        if (algo === algos.DIJKSTRAS) {\r\n            this.dijkstrasVisualize();\r\n        } else if (algo === algos.ASTAR) {\r\n            this.aStarVisualize()\r\n        } else if (algo === algos.BFS) {\r\n            this.bfsVisualize()\r\n        } else if (algo === algos.DFS) {\r\n            this.dfsVisualize()\r\n        }\r\n    }\r\n\r\n    setAlgo(algo) {\r\n        const visualizeButton = document.getElementById(\"visualize\");\r\n        if (algo === algos.DIJKSTRAS) {\r\n            visualizeButton.innerHTML = \"Visualize Dijkstras\";\r\n        } else if (algo === algos.ASTAR) {\r\n            visualizeButton.innerHTML = \"Visualize A*\";\r\n        } else if (algo === algos.BFS) {\r\n            visualizeButton.innerHTML = \"Visualize Breadth First Search\";\r\n        } else if (algo === algos.DFS) {\r\n            visualizeButton.innerHTML = \"Visualize Depth First Search\";\r\n        }\r\n        this.setState({ currAlgo: algo });\r\n    }\r\n\r\n    increaseWeight() {\r\n        const currWallWeight = this.state.wallWeight;\r\n        const wallWeightBadge = document.getElementById('wall-weight');\r\n        if (currWallWeight === Infinity) {\r\n            return;\r\n        } else if (currWallWeight === 5) {\r\n            wallWeightBadge.innerHTML = \"∞\";\r\n            this.setState({ wallWeight: Infinity });\r\n        } else {\r\n            const newWallWeight = currWallWeight + 1;\r\n            wallWeightBadge.innerHTML = newWallWeight;\r\n            this.setState({ wallWeight: newWallWeight });\r\n        }\r\n    }\r\n\r\n    decreaseWeight() {\r\n        const currWallWeight = this.state.wallWeight;\r\n        const wallWeightBadge = document.getElementById('wall-weight');\r\n        if (currWallWeight === 1) {\r\n            return;\r\n        } else if (currWallWeight === Infinity) {\r\n            wallWeightBadge.innerHTML = 5;\r\n            this.setState({ wallWeight: 5 });\r\n        } else {\r\n            const newWallWeight = currWallWeight - 1;\r\n            wallWeightBadge.innerHTML = newWallWeight;\r\n            this.setState({ wallWeight: newWallWeight });\r\n        }\r\n    }\r\n\r\n    setButtonState(state) {\r\n        document.getElementById(\"algo-dropdown\").disabled = state;\r\n        document.getElementById(\"maze-dropdown\").disabled = state;\r\n        document.getElementById(\"visualize\").disabled = state;\r\n        document.getElementById(\"increase-weight\").disabled = state;\r\n        document.getElementById(\"decrease-weight\").disabled = state;\r\n        document.getElementById(\"clear-grid\").disabled = state;\r\n        document.getElementById(\"clear-path\").disabled = state;\r\n    }\r\n\r\n    render() {\r\n        const grid = this.state.grid;\r\n\r\n        return (\r\n            <div className=\"container-fluid\">\r\n                 <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\r\n                    <Navbar.Brand> Pathfinding Visualizer </Navbar.Brand>\r\n                    <DropdownButton variant=\"dark\" id=\"algo-dropdown\" title=\"Choose Algorithm\" className=\"ml-2 mr-2\">\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.DIJKSTRAS)}> Dijkstras </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.ASTAR)}> A* </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.BFS)}> Breadth First Search </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.DFS)}> Depth First Search </Dropdown.Item>\r\n                    </DropdownButton>\r\n                    <DropdownButton variant=\"dark\" id=\"maze-dropdown\" title=\"Generate Maze\" className=\"ml-2 mr-2\">\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.genMaze(this.state.wallWeight)}> Use Selected Weight  </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.genMaze(-1)}> Use Random Weights  </Dropdown.Item>\r\n                    </DropdownButton>\r\n                    <Button id =\"visualize\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.visualize(this.state.currAlgo)}> Visualize Dijkstras </Button>\r\n                    <Navbar.Text id=\"weight-text\" className=\"ml-2\">\r\n                        Wall Weight:\r\n                        <Badge className=\"ml-2 mr-1\" variant=\"light\" id=\"wall-weight\"> ∞ </Badge>\r\n                    </Navbar.Text>\r\n                    <ButtonGroup>\r\n                        <Button id=\"increase-weight\" variant=\"dark\" size=\"sm\" onClick={() => this.increaseWeight()}> + </Button>\r\n                        <Button id=\"decrease-weight\" variant=\"dark\" className=\"mr-2\" size=\"sm\" onClick={() => this.decreaseWeight()}> - </Button>\r\n                    </ButtonGroup>\r\n                    <Button id=\"clear-grid\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.clearGrid()}> Clear Grid </Button>\r\n                    <Button id=\"clear-path\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.clearVistedAndPath()}> Clear Path </Button>\r\n                </Navbar>\r\n                <div className = \"grid\" onMouseUp = {() => this.handleMouseUp()}>\r\n                    {grid.map((row, rowIndex) => {\r\n                    return <div key={rowIndex}>{row.map((node, colIndex) => {\r\n                        return (\r\n                            <Node\r\n                                key = {colIndex}\r\n                                nodeRow = {rowIndex}\r\n                                nodeCol = {colIndex}\r\n                                isStart = {this.isStart(rowIndex, colIndex)}\r\n                                isEnd = {this.isEnd(rowIndex, colIndex)}\r\n                                onMouseDown = {() => this.handleNodeClick(rowIndex, colIndex)}\r\n                                onMouseEnter = {() => this.handleNodeEntered(rowIndex, colIndex)}\r\n                            ></Node>\r\n                        )})}</div>\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getRandomWeight() {\r\n    const min = 1;\r\n    const max = 6;\r\n    const randWeight = Math.floor(Math.random() * (max - min + 1)) + min;\r\n    return randWeight === 6 ? Infinity : randWeight;\r\n}\r\n","export function getPathBFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathBFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function breadthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeQueue = [];\r\n    const startNode = grid[startRow][startCol];\r\n    Object.assign(startNode, {isVisited: true});\r\n    nodeQueue.push(startNode);\r\n\r\n    while (nodeQueue.length !== 0) {\r\n        const visitedNode = nodeQueue.shift();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        // Update node above\r\n        const visitedNodeSet = [];\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                Object.assign(nodeUp, {isVisited: true});\r\n                nodeQueue.push(nodeUp);\r\n                visitedNodeSet.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                Object.assign(nodeDown, {isVisited: true});\r\n                nodeQueue.push(nodeDown);\r\n                visitedNodeSet.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                Object.assign(nodeRight, {isVisited: true});\r\n                nodeQueue.push(nodeRight);\r\n                visitedNodeSet.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                Object.assign(nodeLeft, {isVisited: true});\r\n                nodeQueue.push(nodeLeft);\r\n                visitedNodeSet.push(nodeLeft);\r\n            }\r\n        }\r\n\r\n        if (visitedNodeSet.length > 0) {\r\n            visitedNodes.push(visitedNodeSet);\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","export function getPathDFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathDFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function depthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeStack = [];\r\n    const startNode = grid[startRow][startCol];\r\n    nodeStack.push(startNode);\r\n\r\n    while (nodeStack.length !== 0) {\r\n        const visitedNode = nodeStack.pop();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        if (visitedNode.isVisited) continue;\r\n        Object.assign(visitedNode, {isVisited: true});\r\n        if (visitedNode !== startNode) visitedNodes.push(visitedNode);\r\n\r\n        // Update node above\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                nodeStack.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                nodeStack.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                nodeStack.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                nodeStack.push(nodeLeft);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","import React from 'react';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualization'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinderVisualizer> </PathFinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}