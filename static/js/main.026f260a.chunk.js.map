{"version":3,"sources":["PathFinderVisualizer/Node/Node.jsx","Algorithms/dijkstras.js","Algorithms/MazeGeneration.js","Algorithms/AStarSearch.js","PathFinderVisualizer/PathFinderVisualization.jsx","Algorithms/BreadthFirstSearch.js","Algorithms/DepthFirstSearch.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","mouseClicked","nodeRow","nodeCol","nodeClass","this","isStart","isEnd","handleNodeClick","onMouseDown","handleNodeEntered","onMouseEnter","className","setNodeClass","id","setNodeId","React","Component","minDistance","grid","numRows","numCols","minCoords","min","Infinity","currRow","currCol","isVisited","distance","getPath","currNode","pathArray","parent","push","NodePos","row","col","getOrientation","randomInt","max","Math","floor","random","getManhattanDist","endRow","endCol","abs","nodeIsInList","openList","node","i","length","SCREEN_WIDTH","window","innerWidth","SCREEN_HEIGHT","innerHeight","NUM_ROWS","NUM_COLS","algos","DIJKSTRAS","ASTAR","BFS","DFS","walls","PathFinderVisualizer","currAlgo","wallWeight","running","startNodeClicked","startRow","startCol","endNodeClicked","prevRow","prevCol","createGrid","nextProps","nextState","isFinish","isWall","weight","g","f","j","createNode","setState","document","getElementById","currNodeClassWeight","getNodeClassWeight","isStartNode","isEndNode","currWallWeight","getWallWeightAsInt","updateNodeProps","Object","assign","updateStartProps","updateEndProps","includes","newRow","newCol","oldStartRow","oldStartCol","oldEndRow","oldEndCol","stringWeight","nodeWeight","nodeClassName","clickedNode","updateGridWall","wallClassName","getWallClassName","enteredNode","wallClicked","updateStartNode","updateEndNode","animationTimerTop","animationTimerBot","animationTimerRight","animationTimerLeft","currWallTop","setTimeout","currWallBot","currWallRight","currWallLeft","clearGrid","setButtonState","wallPositions","animationTimer","orientation","genOuterWalls","generateMaze","stratCol","randWallCol","randWallRow","wallCol","wallRow","colRandomizer","rowRandomizer","colPassage","rowPassage","colDir","rowDir","wall","newNumCols","newNumRows","currWall","randomWeight","randWeight","getRandomWeight","clearVistedAndPath","visitedNodes","coords","minNodeRow","minNodeCol","minNode","minNodeDistance","visitedNodeSet","nodeUp","distanceUp","weightUp","nodeDown","distanceDown","weightDown","nodeRight","distanceRight","weightRight","nodeLeft","distanceLeft","weightLeft","dijkstras","visitedNode","visitedNodeDOM","visitedNodeClassName","visitedClassName","substr","path","pathNode","pathNodeDOM","pathNodeClassName","newPathNodeClassName","closedList","startNode","qIdx","splice","isInClosedList","isInOpenList","gNew","fNew","hNew","h","aStarSearch","nodeQueue","shift","visitedUp","visitedDown","visitedRight","visitedLeft","breadthFirstSearch","nodeStack","pop","depthFirstSearch","algo","dijkstrasVisualize","aStarVisualize","bfsVisualize","dfsVisualize","visualizeButton","innerHTML","wallWeightBadge","newWallWeight","disabled","Navbar","bg","variant","expand","Brand","DropdownButton","title","Dropdown","Item","as","onClick","setAlgo","genMaze","Button","visualize","Text","Badge","ButtonGroup","size","increaseWeight","decreaseWeight","onMouseUp","handleMouseUp","map","rowIndex","key","colIndex","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.026f260a.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\n\r\nexport default class Node extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            mouseClicked: false,\r\n        }\r\n    }\r\n\r\n    setNodeId(nodeRow, nodeCol) {\r\n        let nodeID = `row-${nodeRow}-col-${nodeCol}`;\r\n        return nodeID;\r\n    }\r\n\r\n    setNodeClass(nodeRow, nodeCol) {\r\n        let nodeClass = \"node\";\r\n        if (this.props.isStart) {\r\n            nodeClass = \"start-node\";\r\n        } else if (this.props.isEnd) {\r\n            nodeClass = \"end-node\";\r\n        }\r\n        return nodeClass;\r\n    }\r\n\r\n    render() {\r\n        const handleNodeClick = this.props.onMouseDown;\r\n        const handleNodeEntered = this.props.onMouseEnter;\r\n\r\n        return (\r\n        <div \r\n            className= {this.setNodeClass(this.props.nodeRow, this.props.nodeCol)}\r\n            id = {this.setNodeId(this.props.nodeRow, this.props.nodeCol)}\r\n            onMouseDown = {() => handleNodeClick()}\r\n            onMouseEnter = {() => handleNodeEntered()}\r\n        ></div>);\r\n    }\r\n}\r\n","function minDistance(grid, numRows, numCols) {\r\n    let min = Infinity;\r\n    let minCoords;\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0; currCol < numCols; currCol++) {\r\n            if (grid[currRow][currCol].isVisited === false && grid[currRow][currCol].distance <= min) {\r\n                min = grid[currRow][currCol].distance;\r\n                minCoords = {\r\n                    nodeRow: currRow,\r\n                    nodeCol: currCol,\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return minCoords;\r\n}\r\n\r\nexport function getPath(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPath(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function dijkstras(grid, numRows, numCols, endRow, endCol) {\r\n    const visitedNodes = [];\r\n\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0 ; currCol < numCols; currCol++) {\r\n            // Get the node with the min distance and set it to visited\r\n            const coords = minDistance(grid, numRows, numCols);\r\n            const minNodeRow = coords.nodeRow;\r\n            const minNodeCol = coords.nodeCol;\r\n            const minNode = grid[minNodeRow][minNodeCol];\r\n            Object.assign(minNode, {isVisited: true});\r\n            if (minNodeRow === endRow && minNodeCol === endCol) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            const minNodeDistance = minNode.distance;\r\n            const visitedNodeSet = [];\r\n            \r\n            // Update node above\r\n            if (minNodeRow + 1 < numRows) {\r\n                const nodeUp = grid[minNodeRow + 1][minNodeCol];\r\n                const distanceUp = nodeUp.distance;\r\n                const weightUp = nodeUp.weight;\r\n                const visitedUp = nodeUp.isVisited;\r\n                if (visitedUp === false && minNodeDistance + weightUp < distanceUp) {\r\n                    Object.assign(nodeUp, {parent: minNode});\r\n                    Object.assign(nodeUp, {distance: minNodeDistance + weightUp});\r\n                    visitedNodeSet.push(nodeUp);\r\n                }\r\n            }\r\n\r\n            // Update node below\r\n            if (minNodeRow - 1 >= 0) {\r\n                const nodeDown = grid[minNodeRow - 1][minNodeCol];\r\n                const distanceDown = nodeDown.distance;\r\n                const weightDown = nodeDown.weight;\r\n                const visitedDown = nodeDown.isVisited;\r\n                if (visitedDown === false && minNodeDistance + weightDown < distanceDown) {\r\n                    Object.assign(nodeDown, {parent: minNode});\r\n                    Object.assign(nodeDown, {distance: minNodeDistance + weightDown});\r\n                    visitedNodeSet.push(nodeDown);\r\n                }\r\n            }\r\n\r\n            // Update node right\r\n            if (minNodeCol + 1 < numCols) {\r\n                const nodeRight = grid[minNodeRow][minNodeCol + 1];\r\n                const distanceRight = nodeRight.distance;\r\n                const weightRight = nodeRight.weight;\r\n                const visitedRight = nodeRight.isVisited;\r\n                if (visitedRight === false && minNodeDistance + weightRight < distanceRight) {\r\n                    Object.assign(nodeRight, {parent: minNode});\r\n                    Object.assign(nodeRight, {distance: minNodeDistance + weightRight});\r\n                    visitedNodeSet.push(nodeRight);\r\n                }\r\n            }\r\n\r\n            // Update node left\r\n            if (minNodeCol - 1 >= 0) {\r\n                const nodeLeft = grid[minNodeRow][minNodeCol - 1];\r\n                const distanceLeft = nodeLeft.distance;\r\n                const weightLeft = nodeLeft.weight;\r\n                const visitedLeft = nodeLeft.isVisited;\r\n                if (visitedLeft === false && minNodeDistance + weightLeft < distanceLeft) {\r\n                    Object.assign(nodeLeft, {parent: minNode});\r\n                    Object.assign(nodeLeft, {distance: minNodeDistance + weightLeft});\r\n                    visitedNodeSet.push(nodeLeft);\r\n                }\r\n            }\r\n\r\n            if (visitedNodeSet.length > 0) {\r\n                visitedNodes.push(visitedNodeSet);\r\n            }\r\n        }\r\n    }\r\n}\r\n","function NodePos(row, col) {\r\n    this.row = row;\r\n    this.col = col;\r\n}\r\n\r\nexport function generateMaze(row, col, numRows, numCols, orientation, wallPositions, startRow, stratCol, endRow, endCol) {\r\n    if ((numRows <= 2) || (numCols <= 1)) {\r\n        return;\r\n    }\r\n    \r\n    // Get the wall position\r\n    let randWallCol = randomInt(1, numCols - 2);\r\n    let randWallRow = randomInt(1, numRows - 2);\r\n    let wallCol = col + (orientation === \"horizontal\" ? 0 : randWallCol);\r\n    let wallRow = row + (orientation === \"vertical\" ? 0 : randWallRow);\r\n\r\n    // Get the passage position\r\n    let colRandomizer = randomInt(0, 1);\r\n    if (colRandomizer === 1) colRandomizer = numCols - 1;\r\n    let rowRandomizer = randomInt(0, 1);\r\n    if (rowRandomizer === 1) rowRandomizer = numRows - 1;\r\n    const colPassage = wallCol + (orientation === \"horizontal\" ? colRandomizer : 0);\r\n    const rowPassage = wallRow + (orientation === \"vertical\" ? rowRandomizer : 0);\r\n\r\n    // Get the direction the wall should extend\r\n    const colDir = orientation === \"horizontal\" ? 1 : 0;\r\n    const rowDir = orientation === \"vertical\" ? 1 : 0;\r\n\r\n    const length = orientation === \"horizontal\" ? numCols : numRows;\r\n    for (let i = 0; i < length; i++) {\r\n        const notPassage = (wallCol !== colPassage || wallRow !== rowPassage);\r\n        const notStart = (wallCol !== stratCol || wallRow !== startRow);\r\n        const notEnd = (wallCol !== endCol || wallRow !== endRow);\r\n        const createWall = notPassage && notStart && notEnd;\r\n        if (createWall) {\r\n            const wall = new NodePos(wallRow, wallCol);\r\n            wallPositions.push(wall);\r\n        }\r\n        wallCol += colDir;\r\n        wallRow += rowDir;\r\n    }\r\n\r\n    // Recurse on subareas\r\n    let newCol = col;\r\n    let newRow = row;\r\n    let newNumCols = orientation === \"horizontal\" ? numCols : wallCol - col;\r\n    let newNumRows = orientation === \"vertical\" ? numRows : wallRow - row;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n\r\n    newCol = orientation === \"horizontal\" ? col : wallCol + 1;\r\n    newRow = orientation === \"vertical\" ? row : wallRow + 1;\r\n    newNumCols = orientation === \"horizontal\" ? numCols : col + numCols - wallCol - 1;\r\n    newNumRows = orientation === \"vertical\" ? numRows : row + numRows - wallRow - 1;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n}\r\n\r\nfunction getOrientation(numRows, numCols) {\r\n    if (numRows < numCols) {\r\n        return \"vertical\";\r\n    } else {\r\n        return \"horizontal\"\r\n    }\r\n}\r\n\r\nfunction randomInt(min, max) {\r\n    const randNum = Math.floor(Math.random() * (max - min + 1) + min);\r\n    return randNum;\r\n}\r\n","export function aStarSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const openList = [];\r\n    const closedList = [];\r\n    const visitedNodes = [];\r\n\r\n    const startNode = grid[startRow][startCol];\r\n    openList.push(startNode);\r\n\r\n    while(openList.length > 0) {\r\n        // Find node with lowest f val in open list\r\n        let currNode = openList[0];\r\n        let qIdx = 0;\r\n        for (let i = 1; i < openList.length; i++) {\r\n            if (openList[i].f < currNode.f) {\r\n                currNode = openList[i];\r\n                qIdx = i;\r\n            }\r\n        }\r\n\r\n        // Current node is the end node, return\r\n        if (currNode.row === endRow && currNode.col === endCol) {\r\n            return visitedNodes;\r\n        }\r\n\r\n        if (currNode !== startNode) visitedNodes.push(currNode);\r\n\r\n        // Pop Q off open list\r\n        openList.splice(qIdx, 1);\r\n        closedList.push(currNode);\r\n\r\n        // Update node above\r\n        if (currNode.row + 1 < numRows) {\r\n            const nodeUp = grid[currNode.row + 1][currNode.col];\r\n            let isInClosedList = nodeIsInList(closedList, nodeUp);\r\n            let isInOpenList = nodeIsInList(openList, nodeUp);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeUp.weight;\r\n                const hNew = getManhattanDist(nodeUp.row, nodeUp.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeUp.g) {\r\n                    Object.assign(nodeUp, {parent: currNode});\r\n                    Object.assign(nodeUp, {g: gNew});\r\n                    Object.assign(nodeUp, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeUp);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (currNode.row - 1 >= 0) {\r\n            const nodeDown = grid[currNode.row - 1][currNode.col];\r\n            let isInClosedList = nodeIsInList(closedList, nodeDown);\r\n            let isInOpenList = nodeIsInList(openList, nodeDown);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeDown.weight;\r\n                const hNew = getManhattanDist(nodeDown.row, nodeDown.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeDown.g) {\r\n                    Object.assign(nodeDown, {parent: currNode});\r\n                    Object.assign(nodeDown, {g: gNew});\r\n                    Object.assign(nodeDown, {h: hNew});\r\n                    Object.assign(nodeDown, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeDown);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (currNode.col + 1 < numCols) {\r\n            const nodeRight = grid[currNode.row][currNode.col + 1];\r\n            let isInClosedList = nodeIsInList(closedList, nodeRight);\r\n            let isInOpenList = nodeIsInList(openList, nodeRight);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeRight.weight;\r\n                const hNew = getManhattanDist(nodeRight.row, nodeRight.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeRight.g) {\r\n                    Object.assign(nodeRight, {parent: currNode});\r\n                    Object.assign(nodeRight, {g: gNew});\r\n                    Object.assign(nodeRight, {h: hNew});\r\n                    Object.assign(nodeRight, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeRight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (currNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[currNode.row][currNode.col - 1];\r\n            let isInClosedList = nodeIsInList(closedList, nodeLeft);\r\n            let isInOpenList = nodeIsInList(openList, nodeLeft);\r\n\r\n            if (!isInClosedList) {\r\n                const gNew = currNode.g + nodeLeft.weight;\r\n                const hNew = getManhattanDist(nodeLeft.row, nodeLeft.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeLeft.g) {\r\n                    Object.assign(nodeLeft, {parent: currNode});\r\n                    Object.assign(nodeLeft, {g: gNew});\r\n                    Object.assign(nodeLeft, {h: hNew});\r\n                    Object.assign(nodeLeft, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeLeft);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\nfunction getManhattanDist(currRow, currCol, endRow, endCol) {\r\n    return Math.abs(currRow - endRow) + Math.abs(currCol - endCol);\r\n}\r\n\r\nfunction nodeIsInList(openList, node) {\r\n    for (let i = 0; i < openList.length; i++) {\r\n        if (openList[i].row === node.row && openList[i].col === node.col) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport './PathFinderVisualization.css'\r\nimport './Node/Node.css'\r\nimport {dijkstras, getPath} from '../Algorithms/dijkstras';\r\nimport {generateMaze} from '../Algorithms/MazeGeneration';\r\nimport {breadthFirstSearch} from '../Algorithms/BreadthFirstSearch';\r\nimport {depthFirstSearch} from '../Algorithms/DepthFirstSearch';\r\nimport {aStarSearch} from '../Algorithms/AStarSearch'\r\nimport { Button, Dropdown, Navbar, ButtonGroup, DropdownButton, Badge } from 'react-bootstrap';\r\n\r\nconst SCREEN_WIDTH = window.innerWidth;\r\nconst SCREEN_HEIGHT = window.innerHeight;\r\nconst NODE_SIZE = 30;\r\nconst NUM_ROWS = Math.floor((SCREEN_HEIGHT / NODE_SIZE) - 4);\r\nconst NUM_COLS = Math.floor((SCREEN_WIDTH / NODE_SIZE) - 4);\r\nconst ANIMATION_SPEED = 5;\r\nconst algos = {\r\n    DIJKSTRAS: \"dijkstras\",\r\n    ASTAR: \"aStar\",\r\n    BFS: \"bfs\",\r\n    DFS: \"dfs\",\r\n}\r\nconst walls = {\r\n    INFINITY: \"wall-node-infinity\",\r\n    FIVE: \"wall-node-five\",\r\n    FOUR: \"wall-node-four\",\r\n    THREE: \"wall-node-three\",\r\n    TWO: \"wall-node-two\",\r\n    ONE: \"wall-node-one\",\r\n}\r\n\r\nexport default class PathFinderVisualizer extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            currAlgo: algos.DIJKSTRAS,\r\n            wallWeight: Infinity,\r\n            running: false,\r\n            grid: [],\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            startRow: 1,\r\n            startCol: 1,\r\n            endNodeClicked: false,\r\n            endRow: NUM_ROWS - 2,\r\n            endCol: NUM_COLS - 2,\r\n            prevRow: -1,\r\n            prevCol: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.createGrid();\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        // Avoid rerendering entire dom on every setState to avoid performance issues\r\n        if (this.state.mouseClicked) return false;\r\n        return true;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Grid Creation                                   //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    createNode(nodeRow, nodeCol) {\r\n        const isStart = nodeCol === this.state.startCol && nodeRow === this.state.startRow;\r\n        const isFinish = nodeCol === this.state.endCol && nodeRow === this.state.endRow;\r\n        let node = {\r\n            row: nodeRow,\r\n            col: nodeCol,\r\n            isStart: isStart,\r\n            isFinish: isFinish,\r\n            isWall: false,\r\n            isVisited: false,\r\n            weight: 1,\r\n            distance: (isStart) ? 0 : Infinity,\r\n            parent: (isStart) ? \"NO_PARENT\" : null,\r\n            g: (isStart) ? 0 : Infinity,\r\n            f: (isStart) ? 0 : Infinity,\r\n        }\r\n        return node;\r\n    }\r\n\r\n    createGrid() {\r\n        const grid = [];\r\n        for (let i = 0; i < NUM_ROWS; i++) {\r\n            const row = [];\r\n            for (let j = 0; j < NUM_COLS; j++) {\r\n                const node = this.createNode(i, j);\r\n                row.push(node);\r\n            }\r\n            grid.push(row);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Grid Deletion                                   //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    clearGrid() {\r\n        this.createGrid();\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                if (!(currNode.className === \"start-node\") && !(currNode.className === \"end-node\")) {\r\n                    currNode.className = \"node\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearVistedAndPath() {\r\n        const grid = this.state.grid;\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                const nodeIsWall = currNode.className === \"wall-node-infinity\";\r\n\r\n                // Node is a wall with infinite weight, continue\r\n                if (nodeIsWall) continue;\r\n\r\n                // Update the node properties appropriately. If the visited node or path node has a \r\n                //   weight in its class => get that weight and append it to a wall-node classname else update its properties\r\n                const currNodeClassWeight = this.getNodeClassWeight(currNode.className);\r\n                const isStartNode = currNode.className === \"start-node\";\r\n                const isEndNode = currNode.className === \"end-node\";\r\n                if (currNodeClassWeight !== \"\") {\r\n                    currNode.className = \"wall-node\" + currNodeClassWeight;\r\n                    const currWallWeight = this.getWallWeightAsInt(currNodeClassWeight);\r\n                    this.updateNodeProps(currRow, currCol);\r\n                    Object.assign(grid[currRow][currCol], {isWall: true});\r\n                    Object.assign(grid[currRow][currCol], {weight: currWallWeight});\r\n                } else if (isStartNode) {\r\n                    this.updateStartProps(currRow, currCol);\r\n                } else if (isEndNode) {\r\n                    this.updateEndProps(currRow, currCol) ;\r\n                } else {\r\n                    currNode.className = \"node\";\r\n                    this.updateNodeProps(currRow, currCol) ;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                               Grid Updates                                   //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    updateGridWall(nodeRow, nodeCol, weight) {\r\n        // Update the given node to be a regular node then make it a wall and set its weight\r\n        const grid = this.state.grid;\r\n        const currNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const nodeIsWall = currNode.className.includes(\"wall-node\");\r\n        if (nodeIsWall) {\r\n            this.updateNodeProps(nodeRow, nodeCol);\r\n            Object.assign(grid[nodeRow][nodeCol], {isWall: true});\r\n            Object.assign(grid[nodeRow][nodeCol], {weight: weight});\r\n        } if (currNode.className === \"node\") {\r\n            this.updateNodeProps(nodeRow, nodeCol);\r\n        }\r\n    }\r\n\r\n    updateNodeProps(nodeRow, nodeCol) {\r\n        // Update the given node to be a regular node\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartProps(nodeRow, nodeCol) {\r\n        // Update the given node to be a start node\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: \"NO_PARENT\"});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: 0});\r\n    }\r\n\r\n    updateEndProps(nodeRow, nodeCol) {\r\n        // Update the given node to be an end node\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartNode(newRow, newCol) {\r\n        const oldStartRow = this.state.startRow;\r\n        const oldStartCol = this.state.startCol;\r\n\r\n        // Update the old start node to be a regular node\r\n        this.updateNodeProps(oldStartRow, oldStartCol);\r\n\r\n        // Update the entered node to be the new start node\r\n        this.updateStartProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            startRow: newRow,\r\n            startCol: newCol,\r\n        });\r\n    }\r\n\r\n    updateEndNode(newRow, newCol) {\r\n        const oldEndRow = this.state.endRow;\r\n        const oldEndCol = this.state.endCol;\r\n\r\n        // Update the old end node to be a regular node\r\n        this.updateNodeProps(oldEndRow, oldEndCol);\r\n\r\n        // Update the entered node to be the new end node\r\n        this.updateEndProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            endRow: newRow,\r\n            endCol: newCol,\r\n        });\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Helper Functions                                //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    isStart(nodeRow, nodeCol) {\r\n        const isStart = nodeRow === this.state.startRow && nodeCol === this.state.startCol;\r\n        return isStart ? true : false;\r\n    }\r\n    \r\n    isEnd(nodeRow, nodeCol) {\r\n        const isEnd = nodeRow === this.state.endRow && nodeCol === this.state.endCol;\r\n        return isEnd ? true : false;\r\n    }\r\n\r\n    getWallClassName(weight) {\r\n        // Get the appropriate className associated with the given weight\r\n        let wallClassName;\r\n        if (weight === 1) {\r\n            wallClassName = walls.ONE;\r\n        } else if (weight === 2) {\r\n            wallClassName = walls.TWO;\r\n        } else if (weight === 3) {\r\n            wallClassName = walls.THREE;\r\n        } else if (weight === 4) {\r\n            wallClassName = walls.FOUR;\r\n        } else if (weight === 5) {\r\n            wallClassName = walls.FIVE;\r\n        } else {\r\n            wallClassName = walls.INFINITY;\r\n        }\r\n        return wallClassName;\r\n    }\r\n\r\n    getWallWeightAsInt(stringWeight) {\r\n        // Given a wall classname return its integer weight\r\n        let nodeWeight = 1;\r\n        if (stringWeight.includes(\"five\")) {\r\n            nodeWeight = 5;\r\n        } else if (stringWeight.includes(\"four\")) {\r\n            nodeWeight = 4;\r\n        } else if (stringWeight.includes(\"three\")) {\r\n            nodeWeight = 3;\r\n        } else if (stringWeight.includes(\"two\")) {\r\n            nodeWeight = 2;\r\n        } else if (stringWeight.includes(\"one\")) {\r\n            nodeWeight = 1;\r\n        }\r\n        return nodeWeight;\r\n    }\r\n\r\n    getNodeClassWeight(nodeClassName) {\r\n        // Given a classname check if it has a weight in it and return that weight\r\n        //   so it can be appended to a classname\r\n        let nodeWeight = \"\";\r\n        if (nodeClassName.includes(\"five\")) {\r\n            nodeWeight = \"-five\";\r\n        } else if (nodeClassName.includes(\"four\")) {\r\n            nodeWeight = \"-four\";\r\n        } else if (nodeClassName.includes(\"three\")) {\r\n            nodeWeight = \"-three\";\r\n        } else if (nodeClassName.includes(\"two\")) {\r\n            nodeWeight = \"-two\";\r\n        } else if (nodeClassName.includes(\"one\")) {\r\n            nodeWeight = \"-one\";\r\n        }\r\n        return nodeWeight;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Click Handling                                  //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    handleNodeClick(nodeRow, nodeCol) {\r\n        if (this.state.running) return;\r\n        const clickedNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const wallClicked = clickedNode.className.includes(\"wall-node\");\r\n\r\n        if (wallClicked) {\r\n            clickedNode.className = \"node\";\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"node\") {\r\n            const wallClassName = this.getWallClassName(this.state.wallWeight);\r\n            clickedNode.className = wallClassName;\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"end-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                endNodeClicked: true,\r\n            });\r\n        } else if (clickedNode.className === \"start-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                startNodeClicked: true,\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNodeEntered(nodeRow, nodeCol) {\r\n        if (this.state.running) return;\r\n        if (nodeRow === this.state.prevRow && nodeCol === this.state.prevCol) return;\r\n        const enteredNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        const wallClicked = enteredNode.className.includes(\"wall-node\");\r\n        \r\n        if (this.state.startNodeClicked) {\r\n            // Update the entered node to be the start node, update prev node to be a regular node\r\n            if (nodeRow === this.state.endRow && nodeCol === this.state.endCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"start-node\";\r\n            this.updateStartNode(nodeRow, nodeCol);\r\n        } else if (this.state.endNodeClicked) {\r\n            // Update the entered node to be the end node, update prev node to be a regular node\r\n            if (nodeRow === this.state.startRow && nodeCol === this.state.startCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"end-node\";\r\n            this.updateEndNode(nodeRow, nodeCol);\r\n        } else if (this.state.mouseClicked) {\r\n            // Update the entered node to be a wall/regular node respectively\r\n            if (wallClicked) {\r\n                enteredNode.className = \"node\";\r\n            } else if (enteredNode.className === \"node\") {\r\n                const wallClassName = this.getWallClassName(this.state.wallWeight);\r\n                enteredNode.className = wallClassName;\r\n                enteredNode.className = wallClassName;\r\n            }\r\n            this.updateGridWall(nodeRow, nodeCol, this.state.wallWeight);\r\n        }\r\n\r\n        this.setState({\r\n            prevRow: nodeRow,\r\n            prevCol: nodeCol,\r\n        });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            endNodeClicked: false,\r\n        });\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Maze Generation                                 //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    genOuterWalls() {\r\n        let animationTimerTop = 0;\r\n        let animationTimerBot = 0;\r\n        let animationTimerRight = 0\r\n        let animationTimerLeft = 0\r\n        \r\n        // Create the outer top walls from left to right\r\n        for (let i = 0 ; i < NUM_COLS; i++) {\r\n            const currWallTop = document.getElementById(`row-${0}-col-${i}`);\r\n            if (currWallTop.className === \"start-node\" || currWallTop.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallTop.className = \"wall-node-infinity\";\r\n                this.updateGridWall(0, i, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerTop);\r\n            animationTimerTop += 2;\r\n        }\r\n\r\n        // Create the outer bottom walls from right to left\r\n        for (let i = NUM_COLS - 1 ; i >= 0; i--) {\r\n            const currWallBot = document.getElementById(`row-${NUM_ROWS - 1}-col-${i}`);\r\n            if (currWallBot.className === \"start-node\" || currWallBot.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallBot.className = \"wall-node-infinity\";\r\n                this.updateGridWall(NUM_ROWS - 1, i, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerBot);\r\n            animationTimerBot += 2;\r\n        }\r\n\r\n        // Set the animation timers for the vertical walls to be the time it takes for \r\n        //   the horizontal walls to generate\r\n        animationTimerRight = animationTimerLeft = animationTimerTop;\r\n\r\n        // Create the outer right walls from top to bottom\r\n        for (let i = 1; i < NUM_ROWS - 1; i++) {\r\n            const currWallRight = document.getElementById(`row-${i}-col-${NUM_COLS - 1}`);\r\n            if (currWallRight.className === \"start-node\" || currWallRight.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallRight.className = \"wall-node-infinity\";\r\n                this.updateGridWall(i, NUM_COLS - 1, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerRight);\r\n            animationTimerRight += 2;\r\n        }\r\n\r\n        // Create the outer left walls from bottom to top\r\n        for (let i = NUM_ROWS - 2; i >= 0; i--) {\r\n            const currWallLeft = document.getElementById(`row-${i}-col-${0}`);\r\n            if (currWallLeft.className === \"start-node\" || currWallLeft.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallLeft.className = \"wall-node-infinity\";\r\n                this.updateGridWall(i, 0, Infinity);\r\n            }, ANIMATION_SPEED * animationTimerLeft);\r\n            animationTimerLeft += 2;\r\n        }\r\n\r\n        // Return how long it takes to generate all the outer walls\r\n        return animationTimerLeft;\r\n    }\r\n\r\n    genMaze(weight) {\r\n        this.clearGrid();\r\n        this.setButtonState(true);\r\n        this.setState({ running: true });\r\n        const wallPositions = [];\r\n        let animationTimer = 0;\r\n        const orientation = NUM_ROWS < NUM_COLS ? \"vertical\" : \"horizontal\";\r\n        animationTimer = this.genOuterWalls();\r\n\r\n        // Get the wall positions for the generated maze\r\n        generateMaze(1, 1, NUM_ROWS - 2, NUM_COLS - 2, orientation, wallPositions, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n\r\n        // Change each wall position into a wall\r\n        for (let i = 0; i < wallPositions.length; i++) {\r\n            const wallRow = wallPositions[i].row;\r\n            const wallCol = wallPositions[i].col;\r\n            const currWall = document.getElementById(`row-${wallRow}-col-${wallCol}`);\r\n            setTimeout(() => {\r\n                const randomWeight = getRandomWeight();\r\n                const wallWeight = weight === -1 ? randomWeight : weight;\r\n                const wallClassName = this.getWallClassName(wallWeight);\r\n                currWall.className = wallClassName;\r\n                this.updateGridWall(wallRow, wallCol, wallWeight);\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            this.setState({mouseClicked: false});\r\n            animationTimer += 2;\r\n        }\r\n\r\n        // Renable the buttons\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n            this.setState({ running: false });\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                          Algorithm Visualizations                            //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    dijkstrasVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        this.setState({ running: true });\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = dijkstras(grid, NUM_ROWS, NUM_COLS, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                const visitedNodeClassName = visitedNodeDOM.className;\r\n\r\n                // If we are visiting a weighted wall then get the weight and append it to a visited-node classname\r\n                //   else chanmge the classname to be a visited node\r\n                if (visitedNodeClassName.includes(\"wall-node\")) {\r\n                    const wallWeight = visitedNodeClassName.substr(9);\r\n                    const visitedClassName = \"visited-node\" + wallWeight;\r\n                    setTimeout(() => {\r\n                        visitedNodeDOM.className = visitedClassName;\r\n                    }, ANIMATION_SPEED * animationTimer);\r\n                } else {\r\n                    setTimeout(() => {\r\n                        visitedNodeDOM.className = \"visited-node\";\r\n                    }, ANIMATION_SPEED * animationTimer);\r\n                }\r\n            }\r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const pathNodeClassName = pathNodeDOM.className;\r\n            const pathWeight = this.getNodeClassWeight(pathNodeClassName);\r\n\r\n            // If there is a weight in the currentnodes classname then it will be appended else the pathweight\r\n            //   will be empty and nothing will be appended\r\n            const newPathNodeClassName = \"path-node\" + pathWeight;\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = newPathNodeClassName;\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n        \r\n        // Reenable the buttons\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n            this.setState({ running: false });\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    aStarVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        this.setState({ running: true });\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = aStarSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const visitedNode = visitedNodes[i];\r\n            if (visitedNode.isFinish) break;\r\n            const nodeRow = visitedNode.row;\r\n            const nodeCol = visitedNode.col;\r\n            const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const visitedNodeClassName = visitedNodeDOM.className;\r\n            if (visitedNodeClassName.includes(\"wall-node\")) {\r\n                const wallWeight = visitedNodeClassName.substr(9);\r\n                const visitedClassName = \"visited-node\" + wallWeight;\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = visitedClassName;\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            } else {\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 2;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            const pathNodeClassName = pathNodeDOM.className;\r\n            const pathWeight = this.getNodeClassWeight(pathNodeClassName);\r\n            const newPathNodeClassName = \"path-node\" + pathWeight;\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = newPathNodeClassName;\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n            this.setState({ running: false });\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    bfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        this.setState({ running: true });\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = breadthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n            this.setState({ running: false });\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    dfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        this.setButtonState(true);\r\n        this.setState({ running: true });\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = depthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n                const visitedNode = visitedNodes[i];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            \r\n            animationTimer += 4;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) break;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this.setButtonState(false);\r\n            this.setState({ running: false });\r\n        }, ANIMATION_SPEED * animationTimer + 15);\r\n    }\r\n\r\n    visualize(algo) {\r\n        // Run the chosen algorithm\r\n        if (algo === algos.DIJKSTRAS) {\r\n            this.dijkstrasVisualize();\r\n        } else if (algo === algos.ASTAR) {\r\n            this.aStarVisualize()\r\n        } else if (algo === algos.BFS) {\r\n            this.bfsVisualize()\r\n        } else if (algo === algos.DFS) {\r\n            this.dfsVisualize()\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                              Button Functions                                //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    setAlgo(algo) {\r\n        // Update the state to reflect the chosen algorithm\r\n        const visualizeButton = document.getElementById(\"visualize\");\r\n        if (algo === algos.DIJKSTRAS) {\r\n            visualizeButton.innerHTML = \"Visualize Dijkstras\";\r\n        } else if (algo === algos.ASTAR) {\r\n            visualizeButton.innerHTML = \"Visualize A*\";\r\n        } else if (algo === algos.BFS) {\r\n            visualizeButton.innerHTML = \"Visualize Breadth First Search\";\r\n        } else if (algo === algos.DFS) {\r\n            visualizeButton.innerHTML = \"Visualize Depth First Search\";\r\n        }\r\n        this.setState({ currAlgo: algo });\r\n    }\r\n\r\n    increaseWeight() {\r\n        // Increase the counter for the weight badge\r\n        const currWallWeight = this.state.wallWeight;\r\n        const wallWeightBadge = document.getElementById('wall-weight');\r\n        if (currWallWeight === Infinity) {\r\n            return;\r\n        } else if (currWallWeight === 5) {\r\n            wallWeightBadge.innerHTML = \"\";\r\n            this.setState({ wallWeight: Infinity });\r\n        } else {\r\n            const newWallWeight = currWallWeight + 1;\r\n            wallWeightBadge.innerHTML = newWallWeight;\r\n            this.setState({ wallWeight: newWallWeight });\r\n        }\r\n    }\r\n\r\n    decreaseWeight() {\r\n        // Decrease the counter for the weight badge\r\n        const currWallWeight = this.state.wallWeight;\r\n        const wallWeightBadge = document.getElementById('wall-weight');\r\n        if (currWallWeight === 1) {\r\n            return;\r\n        } else if (currWallWeight === Infinity) {\r\n            wallWeightBadge.innerHTML = 5;\r\n            this.setState({ wallWeight: 5 });\r\n        } else {\r\n            const newWallWeight = currWallWeight - 1;\r\n            wallWeightBadge.innerHTML = newWallWeight;\r\n            this.setState({ wallWeight: newWallWeight });\r\n        }\r\n    }\r\n\r\n    setButtonState(state) {\r\n        // Set all the buttons to the given state, true => button is disabled\r\n        document.getElementById(\"algo-dropdown\").disabled = state;\r\n        document.getElementById(\"maze-dropdown\").disabled = state;\r\n        document.getElementById(\"visualize\").disabled = state;\r\n        document.getElementById(\"increase-weight\").disabled = state;\r\n        document.getElementById(\"decrease-weight\").disabled = state;\r\n        document.getElementById(\"clear-grid\").disabled = state;\r\n        document.getElementById(\"clear-path\").disabled = state;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n    //                                  Render                                      //\r\n    //////////////////////////////////////////////////////////////////////////////////\r\n\r\n    render() {\r\n        const grid = this.state.grid;\r\n\r\n        return (\r\n            <div className=\"container-fluid\">\r\n                 <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\r\n                    <Navbar.Brand> Pathfinding Visualizer </Navbar.Brand>\r\n                    <DropdownButton variant=\"dark\" id=\"algo-dropdown\" title=\"Choose Algorithm\" className=\"ml-2 mr-2\">\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.DIJKSTRAS)}> Dijkstras </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.ASTAR)}> A* </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.BFS)}> Breadth First Search </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.setAlgo(algos.DFS)}> Depth First Search </Dropdown.Item>\r\n                    </DropdownButton>\r\n                    <DropdownButton variant=\"dark\" id=\"maze-dropdown\" title=\"Generate Maze\" className=\"ml-2 mr-2\">\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.genMaze(this.state.wallWeight)}> Use Selected Weight  </Dropdown.Item>\r\n                        <Dropdown.Item as=\"button\" onClick={() => this.genMaze(-1)}> Use Random Weights  </Dropdown.Item>\r\n                    </DropdownButton>\r\n                    <Button id =\"visualize\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.visualize(this.state.currAlgo)}> Visualize Dijkstras </Button>\r\n                    <Navbar.Text id=\"weight-text\" className=\"ml-2\">\r\n                        Wall Weight:\r\n                        <Badge className=\"ml-2 mr-1\" variant=\"light\" id=\"wall-weight\">  </Badge>\r\n                    </Navbar.Text>\r\n                    <ButtonGroup>\r\n                        <Button id=\"increase-weight\" variant=\"dark\" size=\"sm\" onClick={() => this.increaseWeight()}> + </Button>\r\n                        <Button id=\"decrease-weight\" variant=\"dark\" className=\"mr-2\" size=\"sm\" onClick={() => this.decreaseWeight()}> - </Button>\r\n                    </ButtonGroup>\r\n                    <Button id=\"clear-grid\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.clearGrid()}> Clear Grid </Button>\r\n                    <Button id=\"clear-path\" className=\"ml-2 mr-2\" variant=\"dark\" onClick={() => this.clearVistedAndPath()}> Clear Path </Button>\r\n                </Navbar>\r\n                <div className = \"grid\" onMouseUp = {() => this.handleMouseUp()}>\r\n                    {grid.map((row, rowIndex) => {\r\n                    return <div key={rowIndex}>{row.map((node, colIndex) => {\r\n                        return (\r\n                            <Node\r\n                                key = {colIndex}\r\n                                nodeRow = {rowIndex}\r\n                                nodeCol = {colIndex}\r\n                                isStart = {this.isStart(rowIndex, colIndex)}\r\n                                isEnd = {this.isEnd(rowIndex, colIndex)}\r\n                                onMouseDown = {() => this.handleNodeClick(rowIndex, colIndex)}\r\n                                onMouseEnter = {() => this.handleNodeEntered(rowIndex, colIndex)}\r\n                            ></Node>\r\n                        )})}</div>\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getRandomWeight() {\r\n    // Get a random number b/w 1 and 6, 6 => make weight infinite\r\n    const min = 1;\r\n    const max = 6;\r\n    const randWeight = Math.floor(Math.random() * (max - min + 1)) + min;\r\n    return randWeight === 6 ? Infinity : randWeight;\r\n}\r\n","export function getPathBFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathBFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function breadthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeQueue = [];\r\n    const startNode = grid[startRow][startCol];\r\n    Object.assign(startNode, {isVisited: true});\r\n    nodeQueue.push(startNode);\r\n\r\n    while (nodeQueue.length !== 0) {\r\n        const visitedNode = nodeQueue.shift();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        // Update node above\r\n        const visitedNodeSet = [];\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                Object.assign(nodeUp, {isVisited: true});\r\n                nodeQueue.push(nodeUp);\r\n                visitedNodeSet.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                Object.assign(nodeDown, {isVisited: true});\r\n                nodeQueue.push(nodeDown);\r\n                visitedNodeSet.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                Object.assign(nodeRight, {isVisited: true});\r\n                nodeQueue.push(nodeRight);\r\n                visitedNodeSet.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                Object.assign(nodeLeft, {isVisited: true});\r\n                nodeQueue.push(nodeLeft);\r\n                visitedNodeSet.push(nodeLeft);\r\n            }\r\n        }\r\n\r\n        if (visitedNodeSet.length > 0) {\r\n            visitedNodes.push(visitedNodeSet);\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","export function getPathDFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathDFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function depthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeStack = [];\r\n    const startNode = grid[startRow][startCol];\r\n    nodeStack.push(startNode);\r\n\r\n    while (nodeStack.length !== 0) {\r\n        const visitedNode = nodeStack.pop();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        if (visitedNode.isVisited) continue;\r\n        Object.assign(visitedNode, {isVisited: true});\r\n        if (visitedNode !== startNode) visitedNodes.push(visitedNode);\r\n\r\n        // Update node above\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                nodeStack.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                nodeStack.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                nodeStack.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                nodeStack.push(nodeLeft);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","import React from 'react';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualization'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinderVisualizer> </PathFinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}