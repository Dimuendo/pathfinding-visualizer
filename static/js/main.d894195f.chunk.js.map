{"version":3,"sources":["PathFinderVisualizer/Node/Node.jsx","Algorithms/dijkstras.js","Algorithms/MazeGeneration.js","Algorithms/AStarSearch.js","PathFinderVisualizer/PathFinderVisualization.jsx","Algorithms/BreadthFirstSearch.js","Algorithms/DepthFirstSearch.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","mouseClicked","nodeRow","nodeCol","nodeClass","this","isStart","isEnd","handleNodeClick","onMouseDown","handleNodeEntered","onMouseEnter","className","setNodeClass","id","setNodeId","React","Component","minDistance","grid","numRows","numCols","minCoords","min","Infinity","currRow","currCol","isVisited","distance","getPath","currNode","pathArray","parent","push","NodePos","row","col","getOrientation","randomInt","max","Math","floor","random","getManhattanDist","endRow","endCol","abs","nodeIsInList","openList","node","i","length","SCREEN_WIDTH","window","innerWidth","SCREEN_HEIGHT","innerHeight","NUM_ROWS","NUM_COLS","PathFinderVisualizer","startNodeClicked","startRow","startCol","endNodeClicked","prevRow","prevCol","createGrid","nextProps","nextState","isFinish","isWall","weight","g","f","j","createNode","setState","document","getElementById","isStartNode","isEndNode","updateStartProps","updateEndProps","updateNodeProps","Object","assign","newRow","newCol","oldStartRow","oldStartCol","oldEndRow","oldEndCol","clickedNode","updateGridWall","enteredNode","updateStartNode","updateEndNode","animationTimerTop","animationTimerBot","animationTimerRight","animationTimerLeft","currWallTop","setTimeout","currWallBot","currWallRight","currWallLeft","clearGrid","wallPositions","animationTimer","orientation","genOuterWalls","generateMaze","stratCol","randWallCol","randWallRow","wallCol","wallRow","colRandomizer","rowRandomizer","colPassage","rowPassage","colDir","rowDir","wall","newNumCols","newNumRows","currWall","clearVistedAndPath","visitedNodes","coords","minNodeRow","minNodeCol","minNode","minNodeDistance","visitedNodeSet","nodeUp","distanceUp","weightUp","nodeDown","distanceDown","weightDown","nodeRight","distanceRight","weightRight","nodeLeft","distanceLeft","weightLeft","dijkstras","path","visitedNode","visitedNodeDOM","pathNode","console","log","pathNodeDOM","closedList","startNode","qIdx","splice","isInClosedList","isInOpenList","gNew","fNew","hNew","h","aStarSearch","nodeQueue","shift","visitedUp","visitedDown","visitedRight","visitedLeft","breadthFirstSearch","nodeStack","pop","depthFirstSearch","onClick","dijkstrasVisualize","aStarVisualize","bfsVisualize","dfsVisualize","genMaze","onMouseUp","handleMouseUp","map","rowIndex","key","colIndex","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d894195f.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\n\r\nexport default class Node extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            mouseClicked: false,\r\n        }\r\n    }\r\n\r\n    setNodeId(nodeRow, nodeCol) {\r\n        let nodeID = `row-${nodeRow}-col-${nodeCol}`;\r\n        return nodeID;\r\n    }\r\n\r\n    setNodeClass(nodeRow, nodeCol) {\r\n        let nodeClass = \"node\";\r\n        if (this.props.isStart) {\r\n            nodeClass = \"start-node\";\r\n        } else if (this.props.isEnd) {\r\n            nodeClass = \"end-node\";\r\n        }\r\n        return nodeClass;\r\n    }\r\n\r\n    render() {\r\n        const handleNodeClick = this.props.onMouseDown;\r\n        const handleNodeEntered = this.props.onMouseEnter;\r\n\r\n        return (\r\n        <div \r\n            className= {this.setNodeClass(this.props.nodeRow, this.props.nodeCol)}\r\n            id = {this.setNodeId(this.props.nodeRow, this.props.nodeCol)}\r\n            onMouseDown = {() => handleNodeClick()}\r\n            onMouseEnter = {() => handleNodeEntered()}\r\n        ></div>);\r\n    }\r\n}\r\n","function minDistance(grid, numRows, numCols) {\r\n    let min = Infinity;\r\n    let minCoords;\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0; currCol < numCols; currCol++) {\r\n            if (grid[currRow][currCol].isVisited === false && grid[currRow][currCol].distance <= min) {\r\n                min = grid[currRow][currCol].distance;\r\n                minCoords = {\r\n                    nodeRow: currRow,\r\n                    nodeCol: currCol,\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return minCoords;\r\n}\r\n\r\nexport function getPath(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPath(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function dijkstras(grid, numRows, numCols, endRow, endCol) {\r\n    const visitedNodes = [];\r\n\r\n    for (let currRow = 0; currRow < numRows; currRow++) {\r\n        for (let currCol = 0 ; currCol < numCols; currCol++) {\r\n            // Get the node with the min distance and set it to visited\r\n            const coords = minDistance(grid, numRows, numCols);\r\n            const minNodeRow = coords.nodeRow;\r\n            const minNodeCol = coords.nodeCol;\r\n            const minNode = grid[minNodeRow][minNodeCol];\r\n            Object.assign(minNode, {isVisited: true});\r\n            if (minNodeRow === endRow && minNodeCol === endCol) {\r\n                return visitedNodes;\r\n            }\r\n\r\n            // Update adjacent nodes\r\n            const minNodeDistance = minNode.distance;\r\n            const visitedNodeSet = [];\r\n            \r\n            // Update node above\r\n            if (minNodeRow + 1 < numRows) {\r\n                const nodeUp = grid[minNodeRow + 1][minNodeCol];\r\n                const distanceUp = nodeUp.distance;\r\n                const weightUp = nodeUp.weight;\r\n                const visitedUp = nodeUp.isVisited;\r\n                if (visitedUp === false && minNodeDistance + weightUp < distanceUp) {\r\n                    Object.assign(nodeUp, {parent: minNode});\r\n                    Object.assign(nodeUp, {distance: minNodeDistance + weightUp});\r\n                    visitedNodeSet.push(nodeUp);\r\n                }\r\n            }\r\n\r\n            // Update node below\r\n            if (minNodeRow - 1 >= 0) {\r\n                const nodeDown = grid[minNodeRow - 1][minNodeCol];\r\n                const distanceDown = nodeDown.distance;\r\n                const weightDown = nodeDown.weight;\r\n                const visitedDown = nodeDown.isVisited;\r\n                if (visitedDown === false && minNodeDistance + weightDown < distanceDown) {\r\n                    Object.assign(nodeDown, {parent: minNode});\r\n                    Object.assign(nodeDown, {distance: minNodeDistance + weightDown});\r\n                    visitedNodeSet.push(nodeDown);\r\n                }\r\n            }\r\n\r\n            // Update node right\r\n            if (minNodeCol + 1 < numCols) {\r\n                const nodeRight = grid[minNodeRow][minNodeCol + 1];\r\n                const distanceRight = nodeRight.distance;\r\n                const weightRight = nodeRight.weight;\r\n                const visitedRight = nodeRight.isVisited;\r\n                if (visitedRight === false && minNodeDistance + weightRight < distanceRight) {\r\n                    Object.assign(nodeRight, {parent: minNode});\r\n                    Object.assign(nodeRight, {distance: minNodeDistance + weightRight});\r\n                    visitedNodeSet.push(nodeRight);\r\n                }\r\n            }\r\n\r\n            // Update node left\r\n            if (minNodeCol - 1 >= 0) {\r\n                const nodeLeft = grid[minNodeRow][minNodeCol - 1];\r\n                const distanceLeft = nodeLeft.distance;\r\n                const weightLeft = nodeLeft.weight;\r\n                const visitedLeft = nodeLeft.isVisited;\r\n                if (visitedLeft === false && minNodeDistance + weightLeft < distanceLeft) {\r\n                    Object.assign(nodeLeft, {parent: minNode});\r\n                    Object.assign(nodeLeft, {distance: minNodeDistance + weightLeft});\r\n                    visitedNodeSet.push(nodeLeft);\r\n                }\r\n            }\r\n\r\n            if (visitedNodeSet.length > 0) {\r\n                visitedNodes.push(visitedNodeSet);\r\n            }\r\n        }\r\n    }\r\n}\r\n","function NodePos(row, col) {\r\n    this.row = row;\r\n    this.col = col;\r\n}\r\n\r\nexport function generateMaze(row, col, numRows, numCols, orientation, wallPositions, startRow, stratCol, endRow, endCol) {\r\n    if ((numRows <= 2) || (numCols <= 1)) {\r\n        return;\r\n    }\r\n    \r\n    // Get the wall position\r\n    let randWallCol = randomInt(1, numCols - 2);\r\n    let randWallRow = randomInt(1, numRows - 2);\r\n    let wallCol = col + (orientation === \"horizontal\" ? 0 : randWallCol);\r\n    let wallRow = row + (orientation === \"vertical\" ? 0 : randWallRow);\r\n\r\n    // Get the passage position\r\n    let colRandomizer = randomInt(0, 1);\r\n    if (colRandomizer === 1) colRandomizer = numCols - 1;\r\n    let rowRandomizer = randomInt(0, 1);\r\n    if (rowRandomizer === 1) rowRandomizer = numRows - 1;\r\n    const colPassage = wallCol + (orientation === \"horizontal\" ? colRandomizer : 0);\r\n    const rowPassage = wallRow + (orientation === \"vertical\" ? rowRandomizer : 0);\r\n\r\n    // Get the direction the wall should extend\r\n    const colDir = orientation === \"horizontal\" ? 1 : 0;\r\n    const rowDir = orientation === \"vertical\" ? 1 : 0;\r\n\r\n    const length = orientation === \"horizontal\" ? numCols : numRows;\r\n    for (let i = 0; i < length; i++) {\r\n        const notPassage = (wallCol !== colPassage || wallRow !== rowPassage);\r\n        const notStart = (wallCol !== stratCol || wallRow !== startRow);\r\n        const notEnd = (wallCol !== endCol || wallRow !== endRow);\r\n        const createWall = notPassage && notStart && notEnd;\r\n        if (createWall) {\r\n            const wall = new NodePos(wallRow, wallCol);\r\n            wallPositions.push(wall);\r\n        }\r\n        wallCol += colDir;\r\n        wallRow += rowDir;\r\n    }\r\n\r\n    let newCol = col;\r\n    let newRow = row;\r\n    let newNumCols = orientation === \"horizontal\" ? numCols : wallCol - col;\r\n    let newNumRows = orientation === \"vertical\" ? numRows : wallRow - row;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n\r\n    newCol = orientation === \"horizontal\" ? col : wallCol + 1;\r\n    newRow = orientation === \"vertical\" ? row : wallRow + 1;\r\n    newNumCols = orientation === \"horizontal\" ? numCols : col + numCols - wallCol - 1;\r\n    newNumRows = orientation === \"vertical\" ? numRows : row + numRows - wallRow - 1;\r\n    generateMaze(newRow, newCol, newNumRows, newNumCols, getOrientation(newNumRows, newNumCols), wallPositions, startRow, stratCol, endRow, endCol);\r\n}\r\n\r\nfunction getOrientation(numRows, numCols) {\r\n    if (numRows < numCols) {\r\n        return \"vertical\";\r\n    } else {\r\n        return \"horizontal\"\r\n    }\r\n}\r\n\r\nfunction randomInt(min, max) {\r\n    const randNum = Math.floor(Math.random() * (max - min + 1) + min);\r\n    return randNum;\r\n}\r\n","export function aStarSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const openList = [];\r\n    const closedList = [];\r\n    const visitedNodes = [];\r\n\r\n    const startNode = grid[startRow][startCol];\r\n    openList.push(startNode);\r\n\r\n    while(openList.length > 0) {\r\n        // Find node with lowest f val in open list\r\n        let currNode = openList[0];\r\n        let qIdx = 0;\r\n        for (let i = 1; i < openList.length; i++) {\r\n            if (openList[i].f < currNode.f) {\r\n                currNode = openList[i];\r\n                qIdx = i;\r\n            }\r\n        }\r\n\r\n        // Current node is the end node, return\r\n        if (currNode.row === endRow && currNode.col === endCol) {\r\n            return visitedNodes;\r\n        }\r\n\r\n        if (currNode !== startNode) visitedNodes.push(currNode);\r\n\r\n        // Pop Q off open list\r\n        openList.splice(qIdx, 1);\r\n        closedList.push(currNode);\r\n\r\n        // Update node above\r\n        if (currNode.row + 1 < numRows) {\r\n            const nodeUp = grid[currNode.row + 1][currNode.col];\r\n            const isWall = nodeUp.isWall;\r\n            let isInClosedList = nodeIsInList(closedList, nodeUp);\r\n            let isInOpenList = nodeIsInList(openList, nodeUp);\r\n\r\n            if (!isWall && !isInClosedList) {\r\n                const gNew = currNode.g + nodeUp.weight;\r\n                const hNew = getManhattanDist(nodeUp.row, nodeUp.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeUp.g) {\r\n                    Object.assign(nodeUp, {parent: currNode});\r\n                    Object.assign(nodeUp, {g: gNew});\r\n                    Object.assign(nodeUp, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeUp);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (currNode.row - 1 >= 0) {\r\n            const nodeDown = grid[currNode.row - 1][currNode.col];\r\n            const isWall = nodeDown.isWall;\r\n            let isInClosedList = nodeIsInList(closedList, nodeDown);\r\n            let isInOpenList = nodeIsInList(openList, nodeDown);\r\n\r\n            if (!isWall && !isInClosedList) {\r\n                const gNew = currNode.g + nodeDown.weight;\r\n                const hNew = getManhattanDist(nodeDown.row, nodeDown.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeDown.g) {\r\n                    Object.assign(nodeDown, {parent: currNode});\r\n                    Object.assign(nodeDown, {g: gNew});\r\n                    Object.assign(nodeDown, {h: hNew});\r\n                    Object.assign(nodeDown, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeDown);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (currNode.col + 1 < numCols) {\r\n            const nodeRight = grid[currNode.row][currNode.col + 1];\r\n            const isWall = nodeRight.isWall;\r\n            let isInClosedList = nodeIsInList(closedList, nodeRight);\r\n            let isInOpenList = nodeIsInList(openList, nodeRight);\r\n\r\n            if (!isWall && !isInClosedList) {\r\n                const gNew = currNode.g + nodeRight.weight;\r\n                const hNew = getManhattanDist(nodeRight.row, nodeRight.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeRight.g) {\r\n                    Object.assign(nodeRight, {parent: currNode});\r\n                    Object.assign(nodeRight, {g: gNew});\r\n                    Object.assign(nodeRight, {h: hNew});\r\n                    Object.assign(nodeRight, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeRight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (currNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[currNode.row][currNode.col - 1];\r\n            const isWall = nodeLeft.isWall;\r\n            let isInClosedList = nodeIsInList(closedList, nodeLeft);\r\n            let isInOpenList = nodeIsInList(openList, nodeLeft);\r\n\r\n            if (!isWall && !isInClosedList) {\r\n                const gNew = currNode.g + nodeLeft.weight;\r\n                const hNew = getManhattanDist(nodeLeft.row, nodeLeft.col, endRow, endCol);\r\n                const fNew = gNew + hNew;\r\n                if (gNew < nodeLeft.g) {\r\n                    Object.assign(nodeLeft, {parent: currNode});\r\n                    Object.assign(nodeLeft, {g: gNew});\r\n                    Object.assign(nodeLeft, {h: hNew});\r\n                    Object.assign(nodeLeft, {f: fNew});\r\n                    if (!isInOpenList) {\r\n                        openList.push(nodeLeft);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\nfunction getManhattanDist(currRow, currCol, endRow, endCol) {\r\n    return Math.abs(currRow - endRow) + Math.abs(currCol - endCol);\r\n}\r\n\r\nfunction nodeIsInList(openList, node) {\r\n    for (let i = 0; i < openList.length; i++) {\r\n        if (openList[i].row === node.row && openList[i].col === node.col) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport './PathFinderVisualization.css'\r\nimport './Node/Node.css'\r\nimport {dijkstras, getPath} from '../Algorithms/dijkstras';\r\nimport {generateMaze} from '../Algorithms/MazeGeneration';\r\nimport {breadthFirstSearch} from '../Algorithms/BreadthFirstSearch';\r\nimport {depthFirstSearch} from '../Algorithms/DepthFirstSearch';\r\nimport {aStarSearch} from '../Algorithms/AStarSearch'\r\n\r\nconst SCREEN_WIDTH = window.innerWidth;\r\nconst SCREEN_HEIGHT = window.innerHeight;\r\nconst NODE_SIZE = 30;\r\nconst NUM_ROWS = Math.floor((SCREEN_HEIGHT / NODE_SIZE) - 4);\r\nconst NUM_COLS = Math.floor((SCREEN_WIDTH / NODE_SIZE) - 4);\r\nconst ANIMATION_SPEED = 10;\r\n\r\nexport default class PathFinderVisualizer extends React.Component{\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            grid: [],\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            startRow: 1,\r\n            startCol: 1,\r\n            endNodeClicked: false,\r\n            endRow: NUM_ROWS - 2,\r\n            endCol: NUM_COLS - 2,\r\n            prevRow: -1,\r\n            prevCol: -1,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.createGrid();\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        if (this.state.mouseClicked) return false;\r\n        return true;\r\n    }\r\n\r\n    createNode(nodeRow, nodeCol) {\r\n        const isStart = nodeCol === this.state.startCol && nodeRow === this.state.startRow;\r\n        const isFinish = nodeCol === this.state.endCol && nodeRow === this.state.endRow;\r\n        let node = {\r\n            row: nodeRow,\r\n            col: nodeCol,\r\n            isStart: isStart,\r\n            isFinish: isFinish,\r\n            isWall: false,\r\n            isVisited: false,\r\n            weight: 1,\r\n            distance: (isStart) ? 0 : Infinity,\r\n            parent: (isStart) ? \"NO_PARENT\" : null,\r\n            g: (isStart) ? 0 : Infinity,\r\n            f: (isStart) ? 0 : Infinity,\r\n        }\r\n        return node;\r\n    }\r\n\r\n    createGrid() {\r\n        const grid = [];\r\n        for (let i = 0; i < NUM_ROWS; i++) {\r\n            const row = [];\r\n            for (let j = 0; j < NUM_COLS; j++) {\r\n                const node = this.createNode(i, j);\r\n                row.push(node);\r\n            }\r\n            grid.push(row);\r\n        }\r\n        this.setState({grid: grid});\r\n    }\r\n\r\n    clearGrid() {\r\n        this.createGrid();\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                if (!(currNode.className === \"start-node\") && !(currNode.className === \"end-node\")) {\r\n                    currNode.className = \"node\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clearVistedAndPath() {\r\n        for (let currRow = 0; currRow < NUM_ROWS; currRow++) {\r\n            for (let currCol = 0; currCol < NUM_COLS; currCol++) {\r\n                const currNode = document.getElementById(`row-${currRow}-col-${currCol}`);\r\n                if (currNode.className === \"wall-node\") continue;\r\n                const isStartNode = currNode.className === \"start-node\";\r\n                const isEndNode = currNode.className === \"end-node\";\r\n                if (isStartNode) {\r\n                    this.updateStartProps(currRow, currCol);\r\n                } else if (isEndNode) {\r\n                    this.updateEndProps(currRow, currCol) ;\r\n                } else {\r\n                    currNode.className = \"node\";\r\n                    this.updateNodeProps(currRow, currCol) ;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateGridWall(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        const currNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        if (currNode.className === \"wall-node\") {\r\n            Object.assign(grid[nodeRow][nodeCol], {isWall: true});\r\n            Object.assign(grid[nodeRow][nodeCol], {weight: Infinity});\r\n        } if (currNode.className === \"node\") {\r\n            Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n            Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        }\r\n    }\r\n\r\n    updateNodeProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: \"NO_PARENT\"});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: 0});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: 0});\r\n    }\r\n\r\n    updateEndProps(nodeRow, nodeCol) {\r\n        const grid = this.state.grid;\r\n        Object.assign(grid[nodeRow][nodeCol], {isStart: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isFinish: true});\r\n        Object.assign(grid[nodeRow][nodeCol], {isWall: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {isVisited: false});\r\n        Object.assign(grid[nodeRow][nodeCol], {weight: 1});\r\n        Object.assign(grid[nodeRow][nodeCol], {distance: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {parent: null});\r\n        Object.assign(grid[nodeRow][nodeCol], {g: Infinity});\r\n        Object.assign(grid[nodeRow][nodeCol], {f: Infinity});\r\n    }\r\n\r\n    updateStartNode(newRow, newCol) {\r\n        const oldStartRow = this.state.startRow;\r\n        const oldStartCol = this.state.startCol;\r\n\r\n        // Update the old start node to be a regular node\r\n        this.updateNodeProps(oldStartRow, oldStartCol);\r\n\r\n        // Update the entered node to be the new start node\r\n        this.updateStartProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            startRow: newRow,\r\n            startCol: newCol,\r\n        });\r\n    }\r\n\r\n    updateEndNode(newRow, newCol) {\r\n        const oldEndRow = this.state.endRow;\r\n        const oldEndCol = this.state.endCol;\r\n\r\n        // Update the old end node to be a regular node\r\n        this.updateNodeProps(oldEndRow, oldEndCol);\r\n\r\n        // Update the entered node to be the new end node\r\n        this.updateEndProps(newRow, newCol);\r\n\r\n        this.setState({\r\n            endRow: newRow,\r\n            endCol: newCol,\r\n        });\r\n    }\r\n\r\n    isStart(nodeRow, nodeCol) {\r\n        const isStart = nodeRow === this.state.startRow && nodeCol === this.state.startCol;\r\n        return isStart ? true : false;\r\n    }\r\n    \r\n    isEnd(nodeRow, nodeCol) {\r\n        const isEnd = nodeRow === this.state.endRow && nodeCol === this.state.endCol;\r\n        return isEnd ? true : false;\r\n    }\r\n\r\n    handleNodeClick(nodeRow, nodeCol) {\r\n        const clickedNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n\r\n        if (clickedNode.className === \"wall-node\") {\r\n            clickedNode.className = \"node\";\r\n            this.updateGridWall(nodeRow, nodeCol);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"node\") {\r\n            clickedNode.className = \"wall-node\";\r\n            this.updateGridWall(nodeRow, nodeCol);\r\n            this.setState({mouseClicked: true});\r\n        } else if (clickedNode.className === \"end-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                endNodeClicked: true,\r\n            });\r\n        } else if (clickedNode.className === \"start-node\") {\r\n            this.setState({\r\n                mouseClicked: true,\r\n                startNodeClicked: true,\r\n            });\r\n        }\r\n    }\r\n\r\n    handleNodeEntered(nodeRow, nodeCol) {\r\n        const enteredNode = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n        if (nodeRow === this.state.prevRow && nodeCol === this.state.prevCol) return;\r\n        \r\n        if (this.state.startNodeClicked) {\r\n            if (nodeRow === this.state.endRow && nodeCol === this.state.endCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"start-node\";\r\n            this.updateStartNode(nodeRow, nodeCol);\r\n        } else if (this.state.endNodeClicked) {\r\n            if (nodeRow === this.state.startRow && nodeCol === this.state.startCol) return;\r\n            const prevNode = document.getElementById(`row-${this.state.prevRow}-col-${this.state.prevCol}`);\r\n            prevNode.className = \"node\";\r\n            enteredNode.className = \"end-node\";\r\n            this.updateEndNode(nodeRow, nodeCol);\r\n        } else if (this.state.mouseClicked) {\r\n            if (enteredNode.className === \"wall-node\") {\r\n                enteredNode.className = \"node\";\r\n            } else if (enteredNode.className === \"node\") {\r\n                enteredNode.className = \"wall-node\";\r\n            }\r\n            this.updateGridWall(nodeRow, nodeCol);\r\n        }\r\n\r\n        this.setState({\r\n            prevRow: nodeRow,\r\n            prevCol: nodeCol,\r\n        });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({\r\n            mouseClicked: false,\r\n            startNodeClicked: false,\r\n            endNodeClicked: false,\r\n        });\r\n    }\r\n\r\n    genOuterWalls() {\r\n        let animationTimerTop = 0;\r\n        let animationTimerBot = 0;\r\n        let animationTimerRight = 0\r\n        let animationTimerLeft = 0\r\n\r\n        for (let i = 0 ; i < NUM_COLS; i++) {\r\n            const currWallTop = document.getElementById(`row-${0}-col-${i}`);\r\n            if (currWallTop.className === \"start-node\" || currWallTop.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallTop.className = \"wall-node\";\r\n                this.updateGridWall(0, i);\r\n            }, ANIMATION_SPEED * animationTimerTop);\r\n            animationTimerTop += 2;\r\n        }\r\n\r\n        for (let i = NUM_COLS - 1 ; i >= 0; i--) {\r\n            const currWallBot = document.getElementById(`row-${NUM_ROWS - 1}-col-${i}`);\r\n            if (currWallBot.className === \"start-node\" || currWallBot.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallBot.className = \"wall-node\";\r\n                this.updateGridWall(NUM_ROWS - 1, i);\r\n            }, ANIMATION_SPEED * animationTimerBot);\r\n            animationTimerBot += 2;\r\n        }\r\n\r\n        animationTimerRight = animationTimerLeft = animationTimerTop;\r\n        for (let i = 1; i < NUM_ROWS - 1; i++) {\r\n            const currWallRight = document.getElementById(`row-${i}-col-${NUM_COLS - 1}`);\r\n            if (currWallRight.className === \"start-node\" || currWallRight.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallRight.className = \"wall-node\";\r\n                this.updateGridWall(i, NUM_COLS - 1);\r\n            }, ANIMATION_SPEED * animationTimerRight);\r\n            animationTimerRight += 2;\r\n        }\r\n\r\n        for (let i = NUM_ROWS - 2; i >= 0; i--) {\r\n            const currWallLeft = document.getElementById(`row-${i}-col-${0}`);\r\n            if (currWallLeft.className === \"start-node\" || currWallLeft.className === \"end-node\") continue;\r\n            setTimeout(() => {\r\n                currWallLeft.className = \"wall-node\";\r\n                this.updateGridWall(i, 0);\r\n            }, ANIMATION_SPEED * animationTimerLeft);\r\n            animationTimerLeft += 2;\r\n        }\r\n\r\n        return animationTimerLeft;\r\n    }\r\n\r\n    genMaze() {\r\n        this.clearGrid();\r\n        const wallPositions = [];\r\n        let animationTimer = 0;\r\n        const orientation = NUM_ROWS < NUM_COLS ? \"vertical\" : \"horizontal\";\r\n        animationTimer = this.genOuterWalls();\r\n        generateMaze(1, 1, NUM_ROWS - 2, NUM_COLS - 2, orientation, wallPositions, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        for (let i = 0; i < wallPositions.length; i++) {\r\n            const wallRow = wallPositions[i].row;\r\n            const wallCol = wallPositions[i].col;\r\n            const currWall = document.getElementById(`row-${wallRow}-col-${wallCol}`);\r\n            setTimeout(() => {\r\n                currWall.className = \"wall-node\";\r\n                this.updateGridWall(wallRow, wallCol);\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            this.setState({mouseClicked: false});\r\n            animationTimer += 2;\r\n        }\r\n\r\n    }\r\n\r\n    dijkstrasVisualize() {\r\n        this.clearVistedAndPath();\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = dijkstras(grid, NUM_ROWS, NUM_COLS, this.state.endRow, this.state.endCol);\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 2;\r\n        }\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) {\r\n                console.log(this.state.grid);\r\n                return;\r\n            }\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n    }\r\n\r\n    aStarVisualize() {\r\n        this.clearVistedAndPath();\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = aStarSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n                const visitedNode = visitedNodes[i];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            \r\n            animationTimer += 2;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) return;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n    }\r\n\r\n    bfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = breadthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            for (let j = 0; j < visitedNodes[i].length; j++) {\r\n                const visitedNode = visitedNodes[i][j];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            }\r\n            animationTimer += 2;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) return;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n    }\r\n\r\n    dfsVisualize() {\r\n        this.clearVistedAndPath();\r\n        const grid = [...this.state.grid];\r\n        const visitedNodes = depthFirstSearch(grid, NUM_ROWS, NUM_COLS, this.state.startRow, this.state.startCol, this.state.endRow, this.state.endCol);\r\n        let animationTimer = 0;\r\n\r\n        // Animate the visited nodes\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n                const visitedNode = visitedNodes[i];\r\n                if (visitedNode.isFinish) break;\r\n                const nodeRow = visitedNode.row;\r\n                const nodeCol = visitedNode.col;\r\n                const visitedNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n                setTimeout(() => {\r\n                    visitedNodeDOM.className = \"visited-node\";\r\n                }, ANIMATION_SPEED * animationTimer);\r\n            \r\n            animationTimer += 2;\r\n        }\r\n\r\n        const path = [];\r\n        getPath(grid, grid[this.state.endRow][this.state.endCol], path);\r\n\r\n        // Animate the path\r\n        for (let i = 0; i < path.length; i++) {\r\n            const pathNode = path[i];\r\n            if (pathNode.isFinish) return;\r\n            const nodeRow = pathNode.row;\r\n            const nodeCol = pathNode.col;\r\n            const pathNodeDOM = document.getElementById(`row-${nodeRow}-col-${nodeCol}`);\r\n            setTimeout(() => {\r\n                pathNodeDOM.className = \"path-node\";\r\n            }, ANIMATION_SPEED * animationTimer);\r\n            animationTimer += 5;\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const grid = this.state.grid;\r\n\r\n        return (\r\n            <div className = \"container\">\r\n                <div className=\"options-bar\">\r\n                    <button id=\"dijkstras\" onClick={() => this.dijkstrasVisualize()}> Visualize Dijkstras  </button>\r\n                    <button id=\"a-star\" onClick={() => this.aStarVisualize()}> Visualize A*  </button>\r\n                    <button id=\"bfs\" onClick={() => this.bfsVisualize()}> Visualize BFS  </button>\r\n                    <button id=\"dfs\" onClick={() => this.dfsVisualize()}> Visualize DFS  </button>\r\n                    <button id=\"clear-grid\" onClick={() => this.clearGrid()}> Clear  </button>\r\n                    <button id=\"gen-maze\" onClick={() => this.genMaze()}> Generate Maze  </button>\r\n                </div>\r\n                <div className = \"grid\" onMouseUp = {() => this.handleMouseUp()}>\r\n                    {grid.map((row, rowIndex) => {\r\n                    return <div key={rowIndex}>{row.map((node, colIndex) => {\r\n                        return (\r\n                            <Node\r\n                                key = {colIndex}\r\n                                nodeRow = {rowIndex}\r\n                                nodeCol = {colIndex}\r\n                                isStart = {this.isStart(rowIndex, colIndex)}\r\n                                isEnd = {this.isEnd(rowIndex, colIndex)}\r\n                                onMouseDown = {() => this.handleNodeClick(rowIndex, colIndex)}\r\n                                onMouseEnter = {() => this.handleNodeEntered(rowIndex, colIndex)}\r\n                            ></Node>\r\n                        )})}</div>\r\n                    })}\r\n                    \r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n","export function getPathBFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathBFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function breadthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeQueue = [];\r\n    const startNode = grid[startRow][startCol];\r\n    Object.assign(startNode, {isVisited: true});\r\n    nodeQueue.push(startNode);\r\n\r\n    while (nodeQueue.length !== 0) {\r\n        const visitedNode = nodeQueue.shift();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        // Update node above\r\n        const visitedNodeSet = [];\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                Object.assign(nodeUp, {isVisited: true});\r\n                nodeQueue.push(nodeUp);\r\n                visitedNodeSet.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                Object.assign(nodeDown, {isVisited: true});\r\n                nodeQueue.push(nodeDown);\r\n                visitedNodeSet.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                Object.assign(nodeRight, {isVisited: true});\r\n                nodeQueue.push(nodeRight);\r\n                visitedNodeSet.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                Object.assign(nodeLeft, {isVisited: true});\r\n                nodeQueue.push(nodeLeft);\r\n                visitedNodeSet.push(nodeLeft);\r\n            }\r\n        }\r\n\r\n        if (visitedNodeSet.length > 0) {\r\n            visitedNodes.push(visitedNodeSet);\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","export function getPathDFS(grid, currNode, pathArray) {\r\n    const parent = currNode.parent;\r\n    if (parent === null) return;\r\n    if (parent === \"NO_PARENT\") {\r\n        return pathArray;\r\n    }\r\n    getPathDFS(grid, parent, pathArray);\r\n    pathArray.push(currNode);\r\n}\r\n\r\nexport function depthFirstSearch(grid, numRows, numCols, startRow, startCol, endRow, endCol) {\r\n    const visitedNodes = [];\r\n    const nodeStack = [];\r\n    const startNode = grid[startRow][startCol];\r\n    nodeStack.push(startNode);\r\n\r\n    while (nodeStack.length !== 0) {\r\n        const visitedNode = nodeStack.pop();\r\n        if (visitedNode.row === endRow && visitedNode.col === endCol) return visitedNodes;\r\n\r\n        if (visitedNode.isVisited) continue;\r\n        Object.assign(visitedNode, {isVisited: true});\r\n        if (visitedNode !== startNode) visitedNodes.push(visitedNode);\r\n\r\n        // Update node above\r\n        if (visitedNode.row + 1 < numRows) {\r\n            const nodeUp = grid[visitedNode.row + 1][visitedNode.col];\r\n            const visitedUp = nodeUp.isVisited;\r\n            const isWall = nodeUp.isWall;\r\n            if (visitedUp === false && isWall === false) {\r\n                Object.assign(nodeUp, {parent: visitedNode});\r\n                nodeStack.push(nodeUp);\r\n            }\r\n        }\r\n\r\n        // Update node below\r\n        if (visitedNode.row - 1 >= 0) {\r\n            const nodeDown = grid[visitedNode.row - 1][visitedNode.col];\r\n            const visitedDown = nodeDown.isVisited;\r\n            const isWall = nodeDown.isWall;\r\n            if (visitedDown === false && isWall === false) {\r\n                Object.assign(nodeDown, {parent: visitedNode});\r\n                nodeStack.push(nodeDown);\r\n            }\r\n        }\r\n\r\n        // Update node right\r\n        if (visitedNode.col + 1 < numCols) {\r\n            const nodeRight = grid[visitedNode.row][visitedNode.col + 1];\r\n            const visitedRight = nodeRight.isVisited;\r\n            const isWall = nodeRight.isWall;\r\n            if (visitedRight === false && isWall === false) {\r\n                Object.assign(nodeRight, {parent: visitedNode});\r\n                nodeStack.push(nodeRight);\r\n            }\r\n        }\r\n\r\n        // Update node left\r\n        if (visitedNode.col - 1 >= 0) {\r\n            const nodeLeft = grid[visitedNode.row][visitedNode.col - 1];\r\n            const visitedLeft = nodeLeft.isVisited;\r\n            const isWall = nodeLeft.isWall;\r\n            if (visitedLeft === false && isWall === false) {\r\n                Object.assign(nodeLeft, {parent: visitedNode});\r\n                nodeStack.push(nodeLeft);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","import React from 'react';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualization'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinderVisualizer> </PathFinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}